{"version":3,"file":"sw-795130e9.js","sources":["src/config/modes.ts","src/config/debug.ts","src/environment/ctx.ts","src/environment/userAgent.ts","src/helpers/context.ts","src/helpers/dT.ts","src/lib/logger.ts","src/helpers/schedulers/pause.ts","src/lib/serviceWorker/cache.ts","src/helpers/blob/readBlobAs.ts","src/helpers/blob/readBlobAsArrayBuffer.ts","src/helpers/blob/readBlobAsUint8Array.ts","src/helpers/noop.ts","src/helpers/cancellablePromise.ts","src/helpers/schedulers/debounce.ts","src/helpers/blob/blobSafeMimeType.ts","src/helpers/blob/blobConstruct.ts","src/lib/files/memoryWriter.ts","src/helpers/makeError.ts","src/lib/files/cacheStorage.ts","src/lib/serviceWorker/timeout.ts","src/lib/serviceWorker/stream.ts","src/config/databases/state.ts","src/config/notifications.ts","src/helpers/object/deepEqual.ts","src/helpers/object/safeAssign.ts","src/lib/files/idb.ts","src/lib/serviceWorker/push.ts","src/config/tabId.ts","src/helpers/array/indexOfAndSplice.ts","src/helpers/array/findAndSplice.ts","src/helpers/eventListenerBase.ts","src/lib/mtproto/superMessagePort.ts","src/lib/serviceWorker/serviceMessagePort.ts","src/helpers/listenMessagePort.ts","src/lib/serviceWorker/download.ts","src/lib/serviceWorker/share.ts","src/lib/serviceWorker/index.service.ts"],"sourcesContent":["/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n *\n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport type {TransportType} from '../lib/mtproto/dcConfigurator';\n\nconst Modes = {\n  test: location.search.indexOf('test=1') > 0/*  || true */,\n  debug: location.search.indexOf('debug=1') > 0,\n  http: false,\n  ssl: true, // location.search.indexOf('ssl=1') > 0 || location.protocol === 'https:' && location.search.indexOf('ssl=0') === -1,\n  multipleConnections: true,\n  asServiceWorker: false,\n  transport: 'websocket' as TransportType,\n  noSharedWorker: location.search.indexOf('noSharedWorker=1') > 0\n};\n\nif(import.meta.env.VITE_MTPROTO_HAS_HTTP) {\n  Modes.http = location.search.indexOf('http=1') > 0;\n}\n\nif(import.meta.env.VITE_MTPROTO_HAS_HTTP || !import.meta.env.VITE_MTPROTO_HAS_WS) {\n  Modes.http = true;\n}\n\nif(Modes.http) {\n  Modes.transport = 'https';\n}\n\nif(import.meta.env.VITE_MTPROTO_SW) {\n  Modes.asServiceWorker = true;\n}\n\nexport default Modes;\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport Modes from './modes';\n\nexport const IS_BETA = import.meta.env.DEV;\nexport const DEBUG = (IS_BETA || Modes.debug)/*  && false */;\nconst ctx: any = typeof(window) !== 'undefined' ? window : self;\nexport const MOUNT_CLASS_TO: any = DEBUG || true/*  && false */ ? ctx : {};\nexport default DEBUG;\n\n// let m = DEBUG;\n/* if(!DEBUG) {\n  ctx.sandpitTurtle = () => {\n    //if(!m) {\n      for(let i in MOUNT_CLASS_TO) {\n        ctx[i] = MOUNT_CLASS_TO[i];\n      }\n      //m = true;\n    //}\n\n    //DEBUG = !DEBUG;\n  };\n} */\n\n/* export const superDebug = (object: any, key: string) => {\n  var d = object[key];\n  var beforeStr = '', afterStr = '';\n  for(var r of d) {\n    beforeStr += r.before.hex + '\\n';\n    afterStr += r.after.hex + '\\n';\n  }\n\n  beforeStr = beforeStr.trim();\n  afterStr = afterStr.trim();\n  //var beforeStr = d.map((r) => r.before.hex).join('\\n');\n  //var afterStr = d.map((r) => r.after.hex).join('\\n');\n\n  var dada = (name: string, str: string) => {\n    var a = document.createElement('a');\n    a.target = '_blank';\n    a.download = name + '.txt';\n    a.href = URL.createObjectURL(new Blob([str], {\n      type: 'text/plain'\n    }));\n    document.body.append(a);\n    a.click();\n  };\n\n  dada(key + '_' + 'before', beforeStr);\n  dada(key + '_' + 'after', afterStr);\n}\n\nMOUNT_CLASS_TO.superDebug = superDebug; */\n","const ctx = typeof(window) !== 'undefined' ? window : self;\n\nexport default ctx;\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport ctx from './ctx';\n\nexport const USER_AGENT = navigator ? navigator.userAgent : null;\nexport const IS_APPLE = navigator.userAgent.search(/OS X|iPhone|iPad|iOS/i) !== -1;\nexport const IS_ANDROID = navigator.userAgent.toLowerCase().indexOf('android') !== -1;\nexport const IS_CHROMIUM = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);\n\n// https://stackoverflow.com/a/58065241\nexport const IS_APPLE_MOBILE = (/iPad|iPhone|iPod/.test(navigator.platform) ||\n  (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1)) &&\n  !(ctx as any).MSStream;\n\nexport const IS_SAFARI = !!('safari' in ctx) || !!(USER_AGENT && (/\\b(iPad|iPhone|iPod)\\b/.test(USER_AGENT) || (!!USER_AGENT.match('Safari') && !USER_AGENT.match('Chrome'))))/*  || true */;\nexport const IS_FIREFOX = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n\nexport const IS_MOBILE_SAFARI = IS_SAFARI && IS_APPLE_MOBILE;\n\nexport const IS_MOBILE = (navigator.maxTouchPoints === undefined || navigator.maxTouchPoints > 0) && navigator.userAgent.search(/iOS|iPhone OS|Android|BlackBerry|BB10|Series ?[64]0|J2ME|MIDP|opera mini|opera mobi|mobi.+Gecko|Windows Phone/i) != -1;\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n// в SW может быть сразу две переменных TRUE\nexport const IS_SERVICE_WORKER = typeof ServiceWorkerGlobalScope !== 'undefined' && self instanceof ServiceWorkerGlobalScope;\nexport const IS_WEB_WORKER = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && !IS_SERVICE_WORKER;\nexport const IS_WORKER = IS_WEB_WORKER || IS_SERVICE_WORKER;\n\nexport const getWindowClients = () => {\n  return (self as any as ServiceWorkerGlobalScope)\n  .clients\n  .matchAll({includeUncontrolled: false, type: 'window'});\n};\n\nexport const getLastWindowClient = () => getWindowClients().then((windowClients) => windowClients.slice(-1)[0]);\n\nconst postMessage = (listener: WindowClient | DedicatedWorkerGlobalScope, ...args: any[]) => {\n  try {\n    // @ts-ignore\n    listener.postMessage(...args);\n  } catch(err) {\n    console.error('[worker] postMessage error:', err, args);\n  }\n};\n\nconst notifyServiceWorker = (all: boolean, ...args: any[]) => {\n  getWindowClients().then((listeners) => {\n    if(!listeners.length) {\n      // console.trace('no listeners?', self, listeners);\n      return;\n    }\n\n    listeners.slice(all ? 0 : -1).forEach((listener) => {\n      postMessage(listener, ...args);\n    });\n  });\n};\n\nconst notifyWorker = (...args: any[]) => {\n  postMessage(self as any as DedicatedWorkerGlobalScope, ...args);\n};\n\nconst noop = () => {};\n\nexport const notifySomeone = IS_SERVICE_WORKER ? notifyServiceWorker.bind(null, false) : (IS_WEB_WORKER ? notifyWorker : noop);\nexport const notifyAll = IS_SERVICE_WORKER ? notifyServiceWorker.bind(null, true) : (IS_WEB_WORKER ? notifyWorker : noop);\n","const _logTimer = Date.now();\nexport default function dT() {\n  return '[' + ((Date.now() - _logTimer) / 1000).toFixed(3) + ']';\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport DEBUG from '../config/debug';\nimport {IS_FIREFOX, IS_SAFARI} from '../environment/userAgent';\nimport {IS_SERVICE_WORKER, IS_WEB_WORKER} from '../helpers/context';\nimport dT from '../helpers/dT';\n\nexport enum LogTypes {\n  None = 0,\n  Error = 1,\n  Warn = 2,\n  Log = 4,\n  Debug = 8\n};\n\nexport const LOG_LEVELS = [LogTypes.None, LogTypes.Error, LogTypes.Warn, LogTypes.Log, LogTypes.Debug];\n\nconst IS_WEBKIT = IS_SAFARI || IS_FIREFOX;\n\n// let getCallerFunctionNameFromLine: (line: string) => string;\n// if(IS_WEBKIT) {\n//   getCallerFunctionNameFromLine = (line) => {\n//     const splitted = line.split('@');\n//     return splitted[0];\n//   };\n// } else {\n//   getCallerFunctionNameFromLine = (line: string) => {\n//     const splitted = line.trim().split(' ');\n//     if(splitted.length === 3) {\n//       return splitted[1].slice(splitted[1].lastIndexOf('.') + 1);\n//     }\n//   };\n// }\n\nconst STYLES_SUPPORTED = !IS_WEBKIT;\n// const LINE_INDEX = IS_WEBKIT ? 2 : 3;\n\n// function getCallerFunctionName() {\n//   const stack = new Error().stack;\n//   const lines = stack.split('\\n');\n//   const line = lines[LINE_INDEX] || lines[lines.length - 1];\n//   // const match = line.match(/\\.([^\\.]+?)\\s/);\n//   // line = match ? match[1] : line.trim();\n//   const caller = getCallerFunctionNameFromLine(line) || '<anonymous>';\n//   return '[' + caller + ']';\n// }\n\nexport const LOGGER_STYLES = {\n  reset: '\\x1b[0m',\n  bright: '\\x1b[1m',\n  dim: '\\x1b[2m',\n  underscore: '\\x1b[4m',\n  blink: '\\x1b[5m',\n  reverse: '\\x1b[7m',\n  hidden: '\\x1b[8m',\n  // Foreground (text) colors\n  fg: {\n    black: '\\x1b[30m',\n    red: '\\x1b[31m',\n    green: '\\x1b[32m',\n    yellow: '\\x1b[33m',\n    blue: '\\x1b[34m',\n    magenta: '\\x1b[35m',\n    cyan: '\\x1b[36m',\n    white: '\\x1b[37m'\n  },\n  // Background colors\n  bg: {\n    black: '\\x1b[40m',\n    red: '\\x1b[41m',\n    green: '\\x1b[42m',\n    yellow: '\\x1b[43m',\n    blue: '\\x1b[44m',\n    magenta: '\\x1b[45m',\n    cyan: '\\x1b[46m',\n    white: '\\x1b[47m'\n  }\n};\n\nexport type Logger = {\n  (...args: any[]): void;\n  warn(...args: any[]): void;\n  info(...args: any[]): void;\n  error(...args: any[]): void;\n  trace(...args: any[]): void;\n  debug(...args: any[]): void;\n  assert(...args: any[]): void;\n  // log(...args: any[]): void;\n  group(...args: any[]): void;\n  groupCollapsed(...args: any[]): void;\n  groupEnd(...args: any[]): void;\n  setPrefix(newPrefix: string): void;\n  setLevel(level: 0 | 1 | 2 | 3 | 4): void;\n  bindPrefix(prefix: string, type?: LogTypes): Logger;\n};\n\nconst methods: ['debug' | 'info' | 'warn' | 'error' | 'assert' | 'trace'/*  | 'log' */ | 'group' | 'groupCollapsed' | 'groupEnd', LogTypes][] = [\n  ['debug', LogTypes.Debug],\n  ['info', LogTypes.Log],\n  ['warn', LogTypes.Warn],\n  ['error', LogTypes.Error],\n  ['assert', LogTypes.Error],\n  ['trace', LogTypes.Log],\n  ['group', LogTypes.Log],\n  ['groupCollapsed', LogTypes.Log],\n  ['groupEnd', LogTypes.Log]\n  // [\"log\", LogTypes.Log]\n];\n\nexport function logger(prefix: string, type: LogTypes = LogTypes.Log | LogTypes.Warn | LogTypes.Error, ignoreDebugReset = false, style = ''): Logger {\n  let originalPrefix: string;\n  if(!DEBUG && !ignoreDebugReset/*  || true */) {\n    type = LogTypes.Error;\n  }\n\n  if(!STYLES_SUPPORTED) {\n    style = '';\n  } else if(!style) {\n    if(IS_SERVICE_WORKER) style = LOGGER_STYLES.fg.yellow;\n    else if(IS_WEB_WORKER) style = LOGGER_STYLES.fg.cyan;\n  }\n\n  const originalStyle = style;\n  if(style) style = `%s ${style}%s`;\n  else style = '%s';\n\n  // level = LogLevels.log | LogLevels.warn | LogLevels.error | LogLevels.debug\n\n  const log: Logger = function(...args: any[]) {\n    return type & LogTypes.Log && console.log(style, dT(), prefix, /* getCallerFunctionName(), */ ...args);\n  } as any;\n\n  methods.forEach(([method, logType]) => {\n    log[method] = function(...args: any[]) {\n      return type & logType && console[method](style, dT(), prefix, /* getCallerFunctionName(), */ ...args);\n    };\n  });\n\n  log.setPrefix = function(newPrefix: string) {\n    originalPrefix = newPrefix;\n    prefix = '[' + newPrefix + ']';\n  };\n\n  log.setPrefix(prefix);\n\n  log.setLevel = function(level: 0 | 1 | 2 | 3 | 4) {\n    type = LOG_LEVELS.slice(0, level + 1).reduce((acc, v) => acc | v, 0) as any;\n  };\n\n  log.bindPrefix = function(prefix: string, _type = type) {\n    return logger(`${originalPrefix}] [${prefix}`, _type, ignoreDebugReset, originalStyle);\n  };\n\n  return log;\n};\n","export default function pause(ms: number) {\n  return new Promise<void>((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport pause from '../../helpers/schedulers/pause';\n\nconst ctx = self as any as ServiceWorkerGlobalScope;\nexport const CACHE_ASSETS_NAME = 'cachedAssets';\n\nfunction isCorrectResponse(response: Response) {\n  return response.ok && response.status === 200;\n}\n\nfunction timeoutRace<T extends Promise<any>>(promise: T) {\n  return Promise.race([\n    promise,\n    pause(10000).then(() => Promise.reject())\n  ]);\n}\n\nexport async function requestCache(event: FetchEvent) {\n  try {\n    // const cache = await ctx.caches.open(CACHE_ASSETS_NAME);\n    const cache = await timeoutRace(ctx.caches.open(CACHE_ASSETS_NAME));\n    const file = await timeoutRace(cache.match(event.request, {ignoreVary: true}));\n\n    if(file && isCorrectResponse(file)) {\n      return file;\n    }\n\n    const headers: HeadersInit = {'Vary': '*'};\n    let response = await fetch(event.request, {headers});\n    if(isCorrectResponse(response)) {\n      cache.put(event.request, response.clone());\n    } else if(response.status === 304) { // possible fix for 304 in Safari\n      const url = event.request.url.replace(/\\?.+$/, '') + '?' + (Math.random() * 100000 | 0);\n      response = await fetch(url, {headers});\n      if(isCorrectResponse(response)) {\n        cache.put(event.request, response.clone());\n      }\n    }\n\n    return response;\n  } catch(err) {\n    return fetch(event.request);\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n// import { IS_WEB_WORKER } from \"../context\";\n\n// const id = IS_WEB_WORKER ? Math.random() * 0x1000 | 0 : 0;\nexport default function readBlobAs(blob: Blob, method: 'readAsText'): Promise<string>;\nexport default function readBlobAs(blob: Blob, method: 'readAsDataURL'): Promise<string>;\nexport default function readBlobAs(blob: Blob, method: 'readAsArrayBuffer'): Promise<ArrayBuffer>;\nexport default function readBlobAs(blob: Blob, method: 'readAsArrayBuffer' | 'readAsText' | 'readAsDataURL'): Promise<any> {\n  // const perf = performance.now();\n  return new Promise<any>((resolve) => {\n    const reader = new FileReader();\n    reader.addEventListener('loadend', (e) => {\n      // console.log(`readBlobAs [${id}] ${method} time ${performance.now() - perf}`);\n      resolve(e.target.result);\n    });\n    reader[method](blob);\n  });\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport readBlobAs from './readBlobAs';\n\nexport default function readBlobAsArrayBuffer(blob: Blob) {\n  return readBlobAs(blob, 'readAsArrayBuffer');\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport readBlobAsArrayBuffer from './readBlobAsArrayBuffer';\n\nexport default function readBlobAsUint8Array(blob: Blob) {\n  return readBlobAsArrayBuffer(blob).then((buffer) => new Uint8Array(buffer));\n}\n","export default function noop() {}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport noop from './noop';\n\nexport interface CancellablePromise<T> extends Promise<T> {\n  resolve?: (value: T) => void,\n  reject?: (...args: any[]) => void,\n  cancel?: (reason?: any) => void,\n\n  notify?: (...args: any[]) => void,\n  notifyAll?: (...args: any[]) => void,\n  lastNotify?: any,\n  listeners?: Array<(...args: any[]) => void>,\n  addNotifyListener?: (callback: (...args: any[]) => void) => void,\n\n  isFulfilled?: boolean,\n  isRejected?: boolean\n}\n\nexport default function deferredPromise<T>() {\n  const deferredHelper: any = {\n    isFulfilled: false,\n    isRejected: false,\n\n    notify: () => {},\n    notifyAll: (...args: any[]) => {\n      deferredHelper.lastNotify = args;\n      deferredHelper.listeners.forEach((callback: any) => callback(...args));\n    },\n\n    listeners: [],\n    addNotifyListener: (callback: (...args: any[]) => void) => {\n      if(deferredHelper.lastNotify) {\n        callback(...deferredHelper.lastNotify);\n      }\n\n      deferredHelper.listeners.push(callback);\n    }\n  };\n\n  const deferred: CancellablePromise<T> = new Promise<T>((resolve, reject) => {\n    deferredHelper.resolve = (value: T) => {\n      if(deferred.isFulfilled || deferred.isRejected) return;\n\n      deferred.isFulfilled = true;\n      resolve(value);\n    };\n\n    deferredHelper.reject = (...args: any[]) => {\n      if(deferred.isRejected || deferred.isFulfilled) return;\n\n      deferred.isRejected = true;\n      reject(...args);\n    };\n  });\n\n  // @ts-ignore\n  /* deferred.then = (resolve: (value: T) => any, reject: (...args: any[]) => any) => {\n    const n = deferredPromise<ReturnType<typeof resolve>>();\n\n  }; */\n\n  deferred.catch(noop).finally(() => {\n    deferred.notify = deferred.notifyAll = deferred.lastNotify = null;\n    deferred.listeners.length = 0;\n\n    if(deferred.cancel) {\n      deferred.cancel = noop;\n    }\n  });\n\n  Object.assign(deferred, deferredHelper);\n\n  return deferred;\n}\n","// * Jolly Cobra's schedulers\n\nimport ctx from '../../environment/ctx';\nimport {AnyFunction, Awaited} from '../../types';\nimport noop from '../noop';\n\nexport type DebounceReturnType<F extends AnyFunction> = {\n  (...args: Parameters<F>): Promise<Awaited<ReturnType<F>>>;\n  clearTimeout(): void;\n  isDebounced(): boolean;\n};\n\nexport default function debounce<F extends AnyFunction>(\n  fn: F,\n  ms: number,\n  shouldRunFirst = true,\n  shouldRunLast = true\n): DebounceReturnType<F> {\n  let waitingTimeout: number;\n  let waitingPromise: Promise<Awaited<ReturnType<F>>>, resolve: (result: any) => void, reject: () => void;\n  let hadNewCall = false;\n\n  const invoke = (args: Parameters<F>) => {\n    const _resolve = resolve, _reject = reject;\n    try {\n      const result = fn.apply(null, args);\n      _resolve(result);\n    } catch(err) {\n      console.error('debounce error', err);\n      // @ts-ignore\n      _reject(err);\n    }\n  };\n\n  const debounce = (...args: Parameters<F>) => {\n    if(!waitingPromise) waitingPromise = new Promise((_resolve, _reject) => (resolve = _resolve, reject = _reject));\n\n    if(waitingTimeout) {\n      clearTimeout(waitingTimeout);\n      hadNewCall = true;\n      reject();\n      waitingPromise = new Promise((_resolve, _reject) => (resolve = _resolve, reject = _reject));\n    } else if(shouldRunFirst) {\n      invoke(args);\n      hadNewCall = false;\n    }\n\n    const _waitingTimeout = ctx.setTimeout(() => {\n      // will run if should run last or first but with new call\n      if(shouldRunLast && (!shouldRunFirst || hadNewCall)) {\n        invoke(args);\n      }\n\n      // if debounce was called during invoking\n      if(waitingTimeout === _waitingTimeout) {\n        waitingTimeout = waitingPromise = resolve = reject = undefined;\n        hadNewCall = false;\n      }\n    }, ms);\n\n    waitingTimeout = _waitingTimeout;\n    waitingPromise.catch(noop);\n    return waitingPromise;\n  };\n\n  debounce.clearTimeout = () => {\n    if(waitingTimeout) {\n      ctx.clearTimeout(waitingTimeout);\n      reject();\n      waitingTimeout = waitingPromise = resolve = reject = undefined;\n      hadNewCall = false;\n    }\n  };\n\n  debounce.isDebounced = () => !!waitingTimeout;\n\n  return debounce;\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n *\n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\n// https://www.iana.org/assignments/media-types/media-types.xhtml\nexport default function blobSafeMimeType(mimeType: string) {\n  if([\n    'image/jpeg',\n    'image/png',\n    'image/gif',\n    'image/svg+xml',\n    'image/webp',\n    'image/bmp',\n    'video/mp4',\n    'video/webm',\n    'video/quicktime',\n    'audio/ogg',\n    'audio/mpeg',\n    'audio/mp4',\n    'audio/wav', // though it is not in list\n    'application/json',\n    'application/pdf'\n  ].indexOf(mimeType) === -1) {\n    return 'application/octet-stream';\n  }\n\n  return mimeType;\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n *\n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport blobSafeMimeType from './blobSafeMimeType';\n\nexport default function blobConstruct<T extends Uint8Array | string>(blobParts: Array<T> | T, mimeType: string = ''): Blob {\n  if(!Array.isArray(blobParts)) {\n    blobParts = [blobParts];\n  }\n\n  const safeMimeType = blobSafeMimeType(mimeType);\n  const blob = new Blob(blobParts, {type: safeMimeType});\n  return blob;\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport blobConstruct from '../../helpers/blob/blobConstruct';\nimport StreamWriter from './streamWriter';\n\nexport default class MemoryWriter implements StreamWriter {\n  private bytes: Uint8Array;\n\n  constructor(\n    private mimeType: string,\n    private size: number,\n    private saveFileCallback?: (blob: Blob) => Promise<Blob>\n  ) {\n    this.bytes = new Uint8Array(size);\n  }\n\n  public async write(part: Uint8Array, offset: number) {\n    // sometimes file size can be bigger than the prov\n    const endOffset = offset + part.byteLength;\n    if(endOffset > this.bytes.byteLength) {\n      const newBytes = new Uint8Array(endOffset);\n      newBytes.set(this.bytes, 0);\n      this.bytes = newBytes;\n    }\n\n    this.bytes.set(part, offset);\n  };\n\n  public truncate() {\n    this.bytes = new Uint8Array();\n  }\n\n  public trim(size: number) {\n    this.bytes = this.bytes.slice(0, size);\n  }\n\n  public finalize(saveToStorage = true) {\n    const blob = blobConstruct(this.bytes, this.mimeType);\n\n    if(saveToStorage && this.saveFileCallback) {\n      this.saveFileCallback(blob);\n    }\n\n    return blob;\n  }\n\n  public getParts() {\n    return this.bytes;\n  }\n\n  public replaceParts(parts: Uint8Array) {\n    this.bytes = parts;\n  }\n}\n","const CACHED_ERRORS: {[key in Error['type']]?: ApiError} = {};\nexport default function makeError(type: Error['type']) {\n  return CACHED_ERRORS[type] ??= {\n    type\n  };\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport Modes from '../../config/modes';\nimport blobConstruct from '../../helpers/blob/blobConstruct';\nimport MemoryWriter from './memoryWriter';\nimport FileManager from './memoryWriter';\nimport FileStorage from './fileStorage';\nimport makeError from '../../helpers/makeError';\nimport deferredPromise from '../../helpers/cancellablePromise';\n\nexport type CacheStorageDbName = 'cachedFiles' | 'cachedStreamChunks' | 'cachedAssets';\n\nexport default class CacheStorageController implements FileStorage {\n  private static STORAGES: CacheStorageController[] = [];\n  private openDbPromise: Promise<Cache>;\n\n  private useStorage = true;\n\n  // private log: ReturnType<typeof logger> = logger('CS');\n\n  constructor(private dbName: CacheStorageDbName) {\n    if(Modes.test) {\n      this.dbName += '_test';\n    }\n\n    if(CacheStorageController.STORAGES.length) {\n      this.useStorage = CacheStorageController.STORAGES[0].useStorage;\n    }\n\n    this.openDatabase();\n    CacheStorageController.STORAGES.push(this);\n  }\n\n  private openDatabase(): Promise<Cache> {\n    return this.openDbPromise ?? (this.openDbPromise = caches.open(this.dbName));\n  }\n\n  public delete(entryName: string) {\n    return this.timeoutOperation((cache) => cache.delete('/' + entryName));\n  }\n\n  public deleteAll() {\n    return caches.delete(this.dbName);\n  }\n\n  public get(entryName: string) {\n    return this.timeoutOperation((cache) => cache.match('/' + entryName));\n  }\n\n  public save(entryName: string, response: Response) {\n    // return new Promise((resolve) => {}); // DEBUG\n    return this.timeoutOperation((cache) => cache.put('/' + entryName, response));\n  }\n\n  public getFile(fileName: string, method: 'blob' | 'json' | 'text' = 'blob'): Promise<any> {\n    // if(method === 'blob') {\n    //   return Promise.reject(makeError('NO_ENTRY_FOUND'));\n    // }\n\n    // const str = `get fileName: ${fileName}`;\n    // console.time(str);\n    return this.get(fileName).then((response) => {\n      if(!response) {\n        // console.warn('getFile:', response, fileName);\n        throw makeError('NO_ENTRY_FOUND');\n      }\n\n      const promise = response[method]();\n      // promise.then(() => {\n      //   console.timeEnd(str);\n      // });\n      return promise;\n    });\n  }\n\n  public saveFile(fileName: string, blob: Blob | Uint8Array) {\n    // return Promise.resolve(blobConstruct([blob]));\n    if(!(blob instanceof Blob)) {\n      blob = blobConstruct(blob);\n    }\n\n    const response = new Response(blob, {\n      headers: {\n        'Content-Length': '' + blob.size\n      }\n    });\n\n    return this.save(fileName, response).then(() => blob as Blob);\n  }\n\n  public timeoutOperation<T>(callback: (cache: Cache) => Promise<T>) {\n    if(!this.useStorage) {\n      return Promise.reject(makeError('STORAGE_OFFLINE'));\n    }\n\n    return new Promise<T>(async(resolve, reject) => {\n      let rejected = false;\n      const timeout = setTimeout(() => {\n        reject();\n        // console.warn('CACHESTORAGE TIMEOUT');\n        rejected = true;\n      }, 15e3);\n\n      try {\n        const cache = await this.openDatabase();\n        if(!cache) {\n          this.useStorage = false;\n          this.openDbPromise = undefined;\n          throw 'no cache?';\n        }\n\n        const res = await callback(cache);\n\n        if(rejected) return;\n        resolve(res);\n      } catch(err) {\n        reject(err);\n      }\n\n      clearTimeout(timeout);\n    });\n  }\n\n  public prepareWriting(fileName: string, fileSize: number, mimeType: string) {\n    return {\n      deferred: deferredPromise<Blob>(),\n      getWriter: () => {\n        const writer = new MemoryWriter(mimeType, fileSize, (blob) => {\n          return this.saveFile(fileName, blob).catch(() => blob);\n        });\n\n        return writer;\n      }\n    };\n  }\n\n  public static toggleStorage(enabled: boolean, clearWrite: boolean) {\n    return Promise.all(this.STORAGES.map((storage) => {\n      storage.useStorage = enabled;\n\n      if(!clearWrite) {\n        return;\n      }\n\n      if(!enabled) {\n        return storage.deleteAll();\n      }\n    }));\n  }\n}\n","export default function timeout(delay: number): Promise<Response> {\n  return new Promise(((resolve) => {\n    setTimeout(() => {\n      resolve(new Response('', {\n        status: 408,\n        statusText: 'Request timed out.'\n      }));\n    }, delay);\n  }));\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport readBlobAsUint8Array from '../../helpers/blob/readBlobAsUint8Array';\nimport deferredPromise, {CancellablePromise} from '../../helpers/cancellablePromise';\nimport debounce from '../../helpers/schedulers/debounce';\nimport {InputFileLocation} from '../../layer';\nimport CacheStorageController from '../files/cacheStorage';\nimport {DownloadOptions, MyUploadFile} from '../mtproto/apiFileManager';\nimport {getMtprotoMessagePort, log, serviceMessagePort} from './index.service';\nimport {ServiceRequestFilePartTaskPayload} from './serviceMessagePort';\nimport timeout from './timeout';\n\nconst deferredPromises: Map<MessagePort, {[taskId: string]: CancellablePromise<MyUploadFile>}> = new Map();\nconst cacheStorage = new CacheStorageController('cachedStreamChunks');\nconst CHUNK_TTL = 86400;\nconst CHUNK_CACHED_TIME_HEADER = 'Time-Cached';\nconst USE_CACHE = true;\n\nconst clearOldChunks = () => {\n  return cacheStorage.timeoutOperation((cache) => {\n    return cache.keys().then((requests) => {\n      const filtered: Map<StreamId, Request> = new Map();\n      const timestamp = Date.now() / 1000 | 0;\n      for(const request of requests) {\n        const match = request.url.match(/\\/(\\d+?)\\?/);\n        if(match && !filtered.has(match[1])) {\n          filtered.set(match[1], request);\n        }\n      }\n\n      const promises: Promise<any>[] = [];\n      for(const [id, request] of filtered) {\n        const promise = cache.match(request).then((response) => {\n          if((+response.headers.get(CHUNK_CACHED_TIME_HEADER) + CHUNK_TTL) <= timestamp) {\n            log('will delete stream chunk:', id);\n            return cache.delete(request, {ignoreSearch: true, ignoreVary: true});\n          }\n        });\n\n        promises.push(promise);\n      }\n\n      return Promise.all(promises);\n    });\n  });\n};\n\nsetInterval(clearOldChunks, 1800e3);\nsetInterval(() => {\n  const mtprotoMessagePort = getMtprotoMessagePort();\n  for(const [messagePort, promises] of deferredPromises) {\n    if(messagePort !== mtprotoMessagePort) {\n      for(const taskId in promises) {\n        const promise = promises[taskId];\n        promise.reject();\n      }\n\n      deferredPromises.delete(messagePort);\n    }\n  }\n}, 120e3);\n\ntype StreamRange = [number, number];\ntype StreamId = DocId;\nconst streams: Map<StreamId, Stream> = new Map();\nclass Stream {\n  private destroyDebounced: () => void;\n  private id: StreamId;\n  private limitPart: number;\n  private loadedOffsets: Set<number> = new Set();\n\n  constructor(private info: DownloadOptions) {\n    this.id = Stream.getId(info);\n    streams.set(this.id, this);\n\n    // ! если грузить очень большое видео чанками по 512Кб в мобильном Safari, то стрим не запустится\n    this.limitPart = info.size > (75 * 1024 * 1024) ? STREAM_CHUNK_UPPER_LIMIT : STREAM_CHUNK_MIDDLE_LIMIT;\n    this.destroyDebounced = debounce(this.destroy, 150000, false, true);\n  }\n\n  private destroy = () => {\n    streams.delete(this.id);\n  };\n\n  private async requestFilePartFromWorker(alignedOffset: number, limit: number, fromPreload = false) {\n    const payload: ServiceRequestFilePartTaskPayload = {\n      docId: this.id,\n      dcId: this.info.dcId,\n      offset: alignedOffset,\n      limit\n    };\n\n    const taskId = JSON.stringify(payload);\n\n    const mtprotoMessagePort = getMtprotoMessagePort();\n    let promises = deferredPromises.get(mtprotoMessagePort);\n    if(!promises) {\n      deferredPromises.set(mtprotoMessagePort, promises = {});\n    }\n\n    let deferred = promises[taskId];\n    if(deferred) {\n      return deferred.then((uploadFile) => uploadFile.bytes);\n    }\n\n    this.loadedOffsets.add(alignedOffset);\n\n    deferred = promises[taskId] = deferredPromise();\n\n    serviceMessagePort.invoke('requestFilePart', payload, undefined, mtprotoMessagePort)\n    .then(deferred.resolve, deferred.reject).finally(() => {\n      if(promises[taskId] === deferred) {\n        delete promises[taskId];\n\n        if(!Object.keys(promises).length) {\n          deferredPromises.delete(mtprotoMessagePort);\n        }\n      }\n    });\n\n    const bytesPromise = deferred.then((uploadFile) => uploadFile.bytes);\n\n    if(USE_CACHE) {\n      this.saveChunkToCache(bytesPromise, alignedOffset, limit);\n      !fromPreload && this.preloadChunks(alignedOffset, alignedOffset + (this.limitPart * 15));\n    }\n\n    return bytesPromise;\n  }\n\n  private requestFilePartFromCache(alignedOffset: number, limit: number, fromPreload?: boolean) {\n    if(!USE_CACHE) {\n      return Promise.resolve();\n    }\n\n    const key = this.getChunkKey(alignedOffset, limit);\n    return cacheStorage.getFile(key).then((blob: Blob) => {\n      return fromPreload ? new Uint8Array() : readBlobAsUint8Array(blob);\n    }, (error: ApiError) => {\n      if(error.type === 'NO_ENTRY_FOUND') {\n        return;\n      }\n    });\n  }\n\n  private requestFilePart(alignedOffset: number, limit: number, fromPreload?: boolean) {\n    return this.requestFilePartFromCache(alignedOffset, limit, fromPreload).then((bytes) => {\n      return bytes || this.requestFilePartFromWorker(alignedOffset, limit, fromPreload);\n    });\n  }\n\n  private saveChunkToCache(deferred: Promise<Uint8Array>, alignedOffset: number, limit: number) {\n    return deferred.then((bytes) => {\n      const key = this.getChunkKey(alignedOffset, limit);\n      const response = new Response(bytes, {\n        headers: {\n          'Content-Length': '' + bytes.length,\n          'Content-Type': 'application/octet-stream',\n          [CHUNK_CACHED_TIME_HEADER]: '' + (Date.now() / 1000 | 0)\n        }\n      });\n\n      return cacheStorage.save(key, response);\n    });\n  }\n\n  private preloadChunk(offset: number) {\n    if(this.loadedOffsets.has(offset)) {\n      return;\n    }\n\n    this.loadedOffsets.add(offset);\n    this.requestFilePart(offset, this.limitPart, true);\n  }\n\n  private preloadChunks(offset: number, end: number) {\n    if(end > this.info.size) {\n      end = this.info.size;\n    }\n\n    if(!offset) { // load last chunk for bounds\n      this.preloadChunk(alignOffset(offset, this.limitPart));\n    } else { // don't preload next chunks before the start\n      for(; offset < end; offset += this.limitPart) {\n        this.preloadChunk(offset);\n      }\n    }\n  }\n\n  public requestRange(range: StreamRange) {\n    this.destroyDebounced();\n\n    const possibleResponse = responseForSafariFirstRange(range, this.info.mimeType, this.info.size);\n    if(possibleResponse) {\n      return possibleResponse;\n    }\n\n    let [offset, end] = range;\n\n    /* if(info.size > limitPart && isSafari && offset === limitPart) {\n      //end = info.size - 1;\n      //offset = info.size - 1 - limitPart;\n      offset = info.size - (info.size % limitPart);\n    } */\n\n    const limit = end && end < this.limitPart ? alignLimit(end - offset + 1) : this.limitPart;\n    const alignedOffset = alignOffset(offset, limit);\n\n    if(!end) {\n      end = Math.min(offset + limit, this.info.size - 1);\n    }\n\n    return this.requestFilePart(alignedOffset, limit).then((ab) => {\n      // log.debug('[stream] requestFilePart result:', result);\n\n      // if(isSafari) {\n      if(offset !== alignedOffset || end !== (alignedOffset + limit)) {\n        ab = ab.slice(offset - alignedOffset, end - alignedOffset + 1);\n      }\n\n      const headers: Record<string, string> = {\n        'Accept-Ranges': 'bytes',\n        'Content-Range': `bytes ${offset}-${offset + ab.byteLength - 1}/${this.info.size || '*'}`,\n        'Content-Length': `${ab.byteLength}`\n      };\n\n      if(this.info.mimeType) {\n        headers['Content-Type'] = this.info.mimeType;\n      }\n\n      // simulate slow connection\n      // setTimeout(() => {\n      return new Response(ab, {\n        status: 206,\n        statusText: 'Partial Content',\n        headers\n      });\n      // }, 2.5e3);\n    });\n  }\n\n  private getChunkKey(alignedOffset: number, limit: number) {\n    return this.id + '?offset=' + alignedOffset + '&limit=' + limit;\n  }\n\n  public static get(info: DownloadOptions) {\n    return streams.get(this.getId(info)) ?? new Stream(info);\n  }\n\n  private static getId(info: DownloadOptions) {\n    return (info.location as InputFileLocation.inputDocumentFileLocation).id;\n  }\n}\n\nexport default function onStreamFetch(event: FetchEvent, params: string) {\n  const range = parseRange(event.request.headers.get('Range'));\n  const info: DownloadOptions = JSON.parse(decodeURIComponent(params));\n  const stream = Stream.get(info);\n\n  // log.debug('[stream]', url, offset, end);\n\n  event.respondWith(Promise.race([\n    timeout(45 * 1000),\n    stream.requestRange(range)\n  ]));\n}\n\nfunction responseForSafariFirstRange(range: StreamRange, mimeType: string, size: number): Response {\n  if(range[0] === 0 && range[1] === 1) {\n    return new Response(new Uint8Array(2).buffer, {\n      status: 206,\n      statusText: 'Partial Content',\n      headers: {\n        'Accept-Ranges': 'bytes',\n        'Content-Range': `bytes 0-1/${size || '*'}`,\n        'Content-Length': '2',\n        'Content-Type': mimeType || 'video/mp4'\n      }\n    });\n  }\n\n  return null;\n}\n\n/* const STREAM_CHUNK_UPPER_LIMIT = 256 * 1024;\nconst SMALLEST_CHUNK_LIMIT = 256 * 4; */\n/* const STREAM_CHUNK_UPPER_LIMIT = 1024 * 1024;\nconst SMALLEST_CHUNK_LIMIT = 1024 * 4; */\nconst STREAM_CHUNK_MIDDLE_LIMIT = 512 * 1024;\nconst STREAM_CHUNK_UPPER_LIMIT = 1024 * 1024;\nconst SMALLEST_CHUNK_LIMIT = 512 * 4;\n\nfunction parseRange(header: string): StreamRange {\n  if(!header) return [0, 0];\n  const [, chunks] = header.split('=');\n  const ranges = chunks.split(', ');\n  const [offset, end] = ranges[0].split('-');\n\n  return [+offset, +end || 0];\n}\n\nfunction alignOffset(offset: number, base = SMALLEST_CHUNK_LIMIT) {\n  return offset - (offset % base);\n}\n\nfunction alignLimit(limit: number) {\n  return 2 ** Math.ceil(Math.log(limit) / Math.log(2));\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type {Database} from '.';\nimport type {IDBIndex} from '../../lib/files/idb';\n\nconst DATABASE_STATE: Database<'session' | 'stickerSets' | 'users' | 'chats' | 'messages' | 'dialogs'> = {\n  name: 'tweb',\n  version: 7,\n  stores: [{\n    name: 'session'\n  }, {\n    name: 'stickerSets'\n  }, {\n    name: 'users'\n  }, {\n    name: 'chats'\n  }, {\n    name: 'dialogs'\n    // indexes: [\n    //   ...(new Array(20 + 2).fill(0)).map((_, idx) => {\n    //     const name = `index_${idx}`;\n    //     const index: IDBIndex = {\n    //       indexName: name,\n    //       keyPath: name,\n    //       objectParameters: {}\n    //     };\n\n    //     return index\n    //   })\n    // ]\n  }, {\n    name: 'messages'\n  }]\n};\n\nexport default DATABASE_STATE;\n","export const NOTIFICATION_ICON_PATH = 'assets/img/logo_filled_rounded.png';\nexport const NOTIFICATION_BADGE_PATH = 'assets/img/logo_plain.svg'; // masked\n","export default function deepEqual(x: any, y: any): boolean {\n  const ok = Object.keys, tx = typeof x, ty = typeof y;\n  return x && y && tx === 'object' && tx === ty ? (\n    ok(x).length === ok(y).length &&\n      ok(x).every((key) => deepEqual(x[key], y[key]))\n  ) : (x === y);\n}\n","export default function safeAssign<T>(object: T, fromObject: any) {\n  if(fromObject) {\n    for(const i in fromObject) {\n      if(fromObject[i] !== undefined) {\n        // @ts-ignore\n        object[i] = fromObject[i];\n      }\n    }\n  }\n\n  return object;\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n *\n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport {Database} from '../../config/databases';\nimport Modes from '../../config/modes';\nimport makeError from '../../helpers/makeError';\nimport safeAssign from '../../helpers/object/safeAssign';\nimport {logger} from '../logger';\n\n/**\n * https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/createIndex\n */\nexport type IDBIndex = {\n  indexName: string,\n  keyPath: string,\n  objectParameters: IDBIndexParameters\n};\n\nexport type IDBStore = {\n  name: string,\n  indexes?: IDBIndex[]\n};\n\nexport type IDBOptions = {\n  name?: string,\n  storeName: string,\n  stores?: IDBStore[],\n  version?: number\n};\n\nconst DEBUG = false;\n\nexport class IDB {\n  private static INSTANCES: IDB[] = [];\n  private openDbPromise: Promise<IDBDatabase>;\n  private db: IDBDatabase;\n  private storageIsAvailable: boolean;\n  private log: ReturnType<typeof logger>;\n  private name: string;\n  private version: number;\n  private stores: IDBStore[];\n\n  constructor(db: Database<any>) {\n    safeAssign(this, db);\n\n    if(Modes.test) {\n      this.name += '_test';\n    }\n\n    this.storageIsAvailable = true;\n    this.log = logger(['IDB', db.name].join('-'));\n    this.log('constructor');\n\n    this.openDatabase(true);\n\n    IDB.INSTANCES.push(this);\n  }\n\n  public isAvailable() {\n    return this.storageIsAvailable;\n  }\n\n  public openDatabase(createNew = false): Promise<IDBDatabase> {\n    if(this.openDbPromise && !createNew) {\n      return this.openDbPromise;\n    }\n\n    const createIndexes = (os: IDBObjectStore, store: IDBStore) => {\n      const indexNames = Array.from(os.indexNames);\n      for(const indexName of indexNames) {\n        os.deleteIndex(indexName);\n      }\n\n      if(!store.indexes?.length) {\n        return;\n      }\n\n      for(const index of store.indexes) {\n        if(os.indexNames.contains(index.indexName)) {\n          continue;\n        }\n\n        os.createIndex(index.indexName, index.keyPath, index.objectParameters);\n      }\n    };\n\n    const createObjectStore = (db: IDBDatabase, store: IDBStore) => {\n      const os = db.createObjectStore(store.name);\n      createIndexes(os, store);\n    };\n\n    try {\n      var request = indexedDB.open(this.name, this.version);\n\n      if(!request) {\n        return Promise.reject();\n      }\n    } catch(error) {\n      this.log.error('error opening db', (error as Error).message);\n      this.storageIsAvailable = false;\n      return Promise.reject(error);\n    }\n\n    let finished = false;\n    setTimeout(() => {\n      if(!finished) {\n        request.onerror(makeError('IDB_CREATE_TIMEOUT') as Event);\n      }\n    }, 3000);\n\n    return this.openDbPromise = new Promise<IDBDatabase>((resolve, reject) => {\n      request.onsuccess = (event) => {\n        finished = true;\n        const db = request.result;\n        let calledNew = false;\n\n        this.log('Opened');\n\n        db.onerror = (error) => {\n          this.storageIsAvailable = false;\n          this.log.error('Error creating/accessing IndexedDB database', error);\n          reject(error);\n        };\n\n        db.onclose = (e) => {\n          this.log.error('closed:', e);\n          !calledNew && this.openDatabase();\n        };\n\n        db.onabort = (e) => {\n          this.log.error('abort:', e);\n          const transaction = e.target as IDBTransaction;\n\n          this.openDatabase(calledNew = true);\n\n          if(transaction.onerror) {\n            transaction.onerror(e);\n          }\n\n          db.close();\n        };\n\n        db.onversionchange = (e) => {\n          this.log.error('onversionchange, lol?');\n        };\n\n        resolve(this.db = db);\n      };\n\n      request.onerror = (event) => {\n        finished = true;\n        this.storageIsAvailable = false;\n        this.log.error('Error creating/accessing IndexedDB database', event);\n        reject(event);\n      };\n\n      request.onupgradeneeded = (event) => {\n        finished = true;\n        this.log.warn('performing idb upgrade from', event.oldVersion, 'to', event.newVersion);\n\n        const target = event.target as IDBOpenDBRequest;\n        const db = target.result;\n        this.stores.forEach((store) => {\n          /* if(db.objectStoreNames.contains(store.name)) {\n            //if(event.oldVersion === 1) {\n              db.deleteObjectStore(store.name);\n            //}\n          } */\n\n          if(!db.objectStoreNames.contains(store.name)) {\n            createObjectStore(db, store);\n          } else {\n            const txn = target.transaction;\n            const os = txn.objectStore(store.name);\n            createIndexes(os, store);\n          }\n        });\n      };\n    });\n  }\n\n  public static create<T extends Database<any>>(db: T) {\n    return this.INSTANCES.find((instance) => instance.name === db.name) ?? new IDB(db);\n  }\n\n  public static closeDatabases(preserve?: IDB) {\n    this.INSTANCES.forEach((storage) => {\n      if(preserve && preserve === storage) {\n        return;\n      }\n\n      const db = storage.db;\n      if(db) {\n        db.onclose = () => {};\n        db.close();\n      }\n    });\n  }\n}\n\nexport default class IDBStorage<T extends Database<any>, StoreName extends string = T['stores'][0]['name']> {\n  private log: ReturnType<typeof logger>;\n  private storeName: T['stores'][0]['name'];\n  private idb: IDB;\n\n  constructor(db: T, storeName: typeof db['stores'][0]['name']) {\n    this.storeName = storeName;\n    this.log = logger(['IDB', db.name, storeName].join('-'));\n    this.idb = IDB.create(db);\n  }\n\n  /**\n   * ! WARNING ! function requires at least one opened connection\n   */\n  /* public static clearObjectStores() {\n    const storage = this.STORAGES[0];\n    this.closeDatabases(storage);\n\n    const names = Array.from(storage.db.objectStoreNames);\n    const promises = names.map((name) => storage.clear(name));\n    return Promise.all(promises);\n  } */\n\n  /* public static deleteDatabase() {\n    this.closeDatabases();\n\n    const storages = this.STORAGES;\n    const dbNames = Array.from(new Set(storages.map((storage) => storage.name)));\n    const promises = dbNames.map((dbName) => {\n      return new Promise<void>((resolve, reject) => {\n        const deleteRequest = indexedDB.deleteDatabase(dbName);\n\n        deleteRequest.onerror = () => {\n          reject();\n        };\n\n        deleteRequest.onsuccess = () => {\n          resolve();\n        };\n      });\n    });\n\n    return Promise.all(promises);\n  } */\n\n  public delete(entryName: string | string[], storeName?: StoreName): Promise<void> {\n    // return Promise.resolve();\n    const isArray = Array.isArray(entryName);\n    if(!isArray) {\n      entryName = [].concat(entryName);\n    }\n\n    return this.getObjectStore('readwrite', (objectStore) => {\n      const promises = (entryName as string[]).map((entryName) => objectStore.delete(entryName));\n      return isArray ? promises : promises[0];\n    }, DEBUG ? 'delete: ' + (entryName as string[]).join(', ') : '', storeName);\n  }\n\n  public clear(storeName?: StoreName): Promise<void> {\n    return this.getObjectStore('readwrite', (objectStore) => objectStore.clear(), DEBUG ? 'clear' : '', storeName);\n  }\n\n  public save(entryName: string | string[], value: any | any[], storeName?: StoreName) {\n    // const handleError = (error: Error) => {\n    //   this.log.error('save: transaction error:', entryName, value, db, error, error && error.name);\n    //   if((!error || error.name === 'InvalidStateError')/*  && false */) {\n    //     setTimeout(() => {\n    //       this.save(entryName, value);\n    //     }, 2e3);\n    //   } else {\n    //     //console.error('IndexedDB saveFile transaction error:', error, error && error.name);\n    //   }\n    // };\n\n    const isArray = Array.isArray(entryName);\n    if(!isArray) {\n      entryName = [].concat(entryName);\n      value = [].concat(value);\n    }\n\n    return this.getObjectStore('readwrite', (objectStore) => {\n      const promises = (entryName as string[]).map((entryName, idx) => objectStore.put(value[idx], entryName));\n      return isArray ? promises : promises[0];\n    }, DEBUG ? 'save: ' + (entryName as string[]).join(', ') : '', storeName);\n  }\n\n  // public saveFile(fileName: string, blob: Blob | Uint8Array) {\n  //   //return Promise.resolve(blobConstruct([blob]));\n  //   if(!(blob instanceof Blob)) {\n  //     blob = blobConstruct(blob);\n  //   }\n\n  //   return this.save(fileName, blob);\n  // }\n\n  /* public saveFileBase64(db: IDBDatabase, fileName: string, blob: Blob | any): Promise<Blob> {\n    if(this.getBlobSize(blob) > 10 * 1024 * 1024) {\n      return Promise.reject();\n    }\n\n    if(!(blob instanceof Blob)) {\n      var safeMimeType = blobSafeMimeType(blob.type || 'image/jpeg');\n      var address = 'data:' + safeMimeType + ';base64,' + bytesToBase64(blob);\n      return this.storagePutB64String(db, fileName, address).then(() => {\n        return blob;\n      });\n    }\n\n    try {\n      var reader = new FileReader();\n    } catch (e) {\n      this.storageIsAvailable = false;\n      return Promise.reject();\n    }\n\n    let promise = new Promise<Blob>((resolve, reject) => {\n      reader.onloadend = () => {\n        this.storagePutB64String(db, fileName, reader.result as string).then(() => {\n          resolve(blob);\n        }, reject);\n      }\n\n      reader.onerror = reject;\n    });\n\n\n    try {\n      reader.readAsDataURL(blob);\n    } catch (e) {\n      this.storageIsAvailable = false;\n      return Promise.reject();\n    }\n\n    return promise;\n  }\n\n  public storagePutB64String(db: IDBDatabase, fileName: string, b64string: string) {\n    try {\n      var objectStore = db.transaction([this.storeName], 'readwrite')\n        .objectStore(this.storeName);\n      var request = objectStore.put(b64string, fileName);\n    } catch(error) {\n      this.storageIsAvailable = false;\n      return Promise.reject(error);\n    }\n\n    return new Promise((resolve, reject) => {\n      request.onsuccess = function(event) {\n        resolve();\n      };\n\n      request.onerror = reject;\n    });\n  }\n\n  public getBlobSize(blob: any) {\n    return blob.size || blob.byteLength || blob.length;\n  } */\n\n  public get<T>(entryName: string[], storeName?: StoreName): Promise<T[]>;\n  public get<T>(entryName: string, storeName?: StoreName): Promise<T>;\n  public get<T>(entryName: string | string[], storeName?: StoreName): Promise<T> | Promise<T[]> {\n    // return Promise.reject();\n\n    const isArray = Array.isArray(entryName);\n    if(!isArray) {\n      if(!entryName) {\n        return undefined;\n      }\n\n      entryName = [].concat(entryName);\n    } else if(!entryName.length) {\n      return Promise.resolve([]) as any;\n    }\n\n    return this.getObjectStore<T>('readonly', (objectStore) => {\n      const promises = (entryName as string[]).map((entryName) => objectStore.get(entryName));\n      return isArray ? promises : promises[0];\n    }, DEBUG ? 'get: ' + (entryName as string[]).join(', ') : '', storeName);\n  }\n\n  private getObjectStore<T>(\n    mode: IDBTransactionMode,\n    callback: (objectStore: IDBObjectStore) => IDBRequest | IDBRequest[],\n    log?: string,\n    storeName = this.storeName\n  ) {\n    let perf: number;\n\n    if(log) {\n      perf = performance.now();\n      this.log(log + ': start');\n    }\n\n    return this.idb.openDatabase().then((db) => {\n      return new Promise<T>((resolve, reject) => {\n        /* if(mode === 'readwrite') {\n          return;\n        } */\n\n        const transaction = db.transaction([storeName], mode);\n\n        const onError = () => {\n          clearTimeout(timeout);\n          reject(transaction.error);\n        };\n\n        // let resolved = false;\n        const onComplete = (/* what: string */) => {\n          clearTimeout(timeout);\n\n          if(log) {\n            this.log(log + ': end', performance.now() - perf/* , what */);\n          }\n\n          // if(resolved) {\n          //   return;\n          // }\n\n          // resolved = true;\n          const results = requests.map((r) => r.result);\n          resolve(isArray ? results : results[0]);\n        };\n\n        transaction.onerror = onError;\n\n        // * have to wait while clearing or setting something\n        const waitForTransactionComplete = mode === 'readwrite';\n        if(waitForTransactionComplete) {\n          transaction.oncomplete = () => onComplete(/* 'transaction' */);\n        }\n\n        const timeout = setTimeout(() => {\n          this.log.error('transaction not finished', transaction, log);\n        }, 10000);\n\n        /* transaction.addEventListener('abort', (e) => {\n          //handleError();\n          this.log.error('IndexedDB: transaction abort!', transaction.error);\n        }); */\n\n        const callbackResult = callback(transaction.objectStore(storeName));\n\n        const isArray = Array.isArray(callbackResult);\n        const requests: IDBRequest[] = isArray ? callbackResult : [].concat(callbackResult) as any;\n\n        if(waitForTransactionComplete) {\n          return;\n        }\n\n        const length = requests.length;\n        let left = length;\n\n        const onRequestFinished = () => {\n          if(transaction.error) {\n            return;\n          }\n\n          if(!--left) {\n            onComplete(/* 'requests' */);\n          }\n        };\n\n        for(let i = 0; i < length; ++i) {\n          const request = requests[i];\n          request.onerror = onError;\n          request.onsuccess = onRequestFinished;\n        }\n      });\n    });\n  }\n\n  public getAll<T>(storeName?: StoreName): Promise<T[]> {\n    return this.getObjectStore<T[]>('readonly', (objectStore) => objectStore.getAll(), DEBUG ? 'getAll' : '', storeName);\n  }\n\n  /* public getAllKeys(): Promise<Array<string>> {\n    console.time('getAllEntries');\n    return this.openDatabase().then((db) => {\n      var objectStore = db.transaction([this.storeName], 'readonly')\n        .objectStore(this.storeName);\n      var request = objectStore.getAllKeys();\n\n      return new Promise((resolve, reject) => {\n        request.onsuccess = function(event) {\n          // @ts-ignore\n          var result = event.target.result;\n          resolve(result);\n          console.timeEnd('getAllEntries');\n        }\n\n        request.onerror = reject;\n      });\n    });\n  } */\n\n  /* public isFileExists(fileName: string): Promise<boolean> {\n    console.time('isFileExists');\n    return this.openDatabase().then((db) => {\n      var objectStore = db.transaction([this.storeName], 'readonly')\n        .objectStore(this.storeName);\n      var request = objectStore.openCursor(fileName);\n\n      return new Promise((resolve, reject) => {\n        request.onsuccess = function(event) {\n          // @ts-ignore\n          var cursor = event.target.result;\n          resolve(!!cursor);\n          console.timeEnd('isFileExists');\n        }\n\n        request.onerror = reject;\n      });\n    });\n  } */\n\n  /* public getFileWriter(fileName: string, mimeType: string) {\n    var fakeWriter = FileManager.getFakeFileWriter(mimeType, (blob) => {\n      return this.saveFile(fileName, blob);\n    });\n\n    return Promise.resolve(fakeWriter);\n  } */\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n *\n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport {Database} from '../../config/databases';\nimport DATABASE_STATE from '../../config/databases/state';\nimport {NOTIFICATION_BADGE_PATH, NOTIFICATION_ICON_PATH} from '../../config/notifications';\nimport {IS_FIREFOX} from '../../environment/userAgent';\nimport deepEqual from '../../helpers/object/deepEqual';\nimport IDBStorage from '../files/idb';\nimport {log, serviceMessagePort} from './index.service';\nimport {ServicePushPingTaskPayload} from './serviceMessagePort';\n\nconst ctx = self as any as ServiceWorkerGlobalScope;\nconst defaultBaseUrl = location.protocol + '//' + location.hostname + location.pathname.split('/').slice(0, -1).join('/') + '/';\n\n// as in webPushApiManager.ts\nconst PING_PUSH_TIMEOUT = 10000 + 1500;\nlet lastPingTime = 0;\nlet localNotificationsAvailable = true;\n\nexport type PushNotificationObject = {\n  loc_key: string,\n  loc_args: string[],\n  // user_id: number, // should be number\n  custom: {\n    channel_id?: string, // should be number\n    chat_id?: string, // should be number\n    from_id?: string, // should be number\n    msg_id: string,\n    peerId?: string, // should be number\n    silent?: string // can be '1'\n  },\n  sound?: string,\n  random_id: number,\n  badge?: string, // should be number\n  description: string,\n  mute: string, // should be number\n  title: string,\n  message?: string,\n} & {\n  action?: 'mute1d' | 'push_settings', // will be set before postMessage to main thread\n};\n\nclass SomethingGetter<T extends Database<any>, Storage extends Record<string, any>> {\n  private cache: Partial<Storage> = {};\n  private storage: IDBStorage<T>;\n\n  constructor(\n    db: T,\n    storeName: typeof db['stores'][number]['name'],\n    private defaults: {\n      [Property in keyof Storage]: ((value: Storage[Property]) => Storage[Property]) | Storage[Property]\n    }\n  ) {\n    this.storage = new IDBStorage<T>(db, storeName);\n  }\n\n  private getDefault<T extends keyof Storage>(key: T) {\n    const callback = this.defaults[key];\n    return typeof(callback) === 'function' ? callback() : callback;\n  }\n\n  public get<T extends keyof Storage>(key: T) {\n    if(this.cache.hasOwnProperty(key)) {\n      return this.cache[key];\n    }\n\n    const promise = this.storage.get(key as string) as Promise<Storage[T]>;\n    return promise.then((value) => value, () => undefined as Storage[T]).then((value) => {\n      if(this.cache.hasOwnProperty(key)) {\n        return this.cache[key];\n      }\n\n      value ??= this.getDefault(key);\n\n      return this.cache[key] = value;\n    });\n  }\n\n  public getCached<T extends keyof Storage>(key: T) {\n    const value = this.get(key);\n    if(value instanceof Promise) {\n      throw 'no property';\n    }\n\n    return value;\n  }\n\n  public async set<T extends keyof Storage>(key: T, value: Storage[T]) {\n    const cached = this.cache[key] ?? this.defaults[key];\n    if(deepEqual(cached, value)) {\n      return;\n    }\n\n    this.cache[key] = value;\n\n    try {\n      this.storage.save(key as string, value);\n    } catch(err) {\n\n    }\n  }\n}\n\ntype PushStorage = {\n  push_mute_until: number,\n  push_lang: Partial<ServicePushPingTaskPayload['lang']>\n  push_settings: Partial<ServicePushPingTaskPayload['settings']>\n};\n\nconst defaults: PushStorage = {\n  push_mute_until: 0,\n  push_lang: {\n    push_message_nopreview: 'You have a new message',\n    push_action_mute1d: 'Mute for 24H',\n    push_action_settings: 'Settings'\n  },\n  push_settings: {}\n};\n\nconst getter = new SomethingGetter<typeof DATABASE_STATE, PushStorage>(DATABASE_STATE, 'session', defaults);\n\n// fill cache\nfor(const i in defaults) {\n  getter.get(i as keyof PushStorage);\n}\n\nctx.addEventListener('push', (event) => {\n  const obj: PushNotificationObject = event.data.json();\n  log('push', {...obj});\n\n  try {\n    const [muteUntil, settings, lang] = [\n      getter.getCached('push_mute_until'),\n      getter.getCached('push_settings'),\n      getter.getCached('push_lang')\n    ];\n\n    const nowTime = Date.now();\n    if(\n      userInvisibleIsSupported() &&\n      muteUntil &&\n      nowTime < muteUntil\n    ) {\n      throw `supress notification because mute for ${Math.ceil((muteUntil - nowTime) / 60000)} min`;\n    }\n\n    const hasActiveWindows = (Date.now() - lastPingTime) <= PING_PUSH_TIMEOUT && localNotificationsAvailable;\n    if(hasActiveWindows) {\n      throw 'supress notification because some instance is alive';\n    }\n\n    const notificationPromise = fireNotification(obj, settings, lang);\n    event.waitUntil(notificationPromise);\n  } catch(err) {\n    log(err);\n\n    // const tag = 'fix';\n    // const notificationPromise = ctx.registration.showNotification('Telegram', {tag});\n\n    // notificationPromise.then(() => {\n    //   closeAllNotifications(tag);\n    // });\n\n    // event.waitUntil(notificationPromise);\n  }\n});\n\nctx.addEventListener('notificationclick', (event) => {\n  const notification = event.notification;\n  log('on notification click', notification);\n  notification.close();\n\n  const action = event.action as PushNotificationObject['action'];\n  if(action === 'mute1d' && userInvisibleIsSupported()) {\n    log('[SW] mute for 1d');\n    getter.set('push_mute_until', Date.now() + 86400e3);\n    return;\n  }\n\n  const data: PushNotificationObject = notification.data;\n  if(!data) {\n    return;\n  }\n\n  const promise = ctx.clients.matchAll({\n    type: 'window'\n  }).then((clientList) => {\n    data.action = action;\n    pendingNotification = data;\n    for(let i = 0; i < clientList.length; ++i) {\n      const client = clientList[i];\n      if('focus' in client) {\n        client.focus();\n        serviceMessagePort.invokeVoid('pushClick', pendingNotification, client);\n        pendingNotification = undefined;\n        return;\n      }\n    }\n\n    if(ctx.clients.openWindow) {\n      return Promise.resolve(getter.get('push_settings')).then((settings) => {\n        return ctx.clients.openWindow(settings.baseUrl || defaultBaseUrl);\n      });\n    }\n  }).catch((error) => {\n    log.error('Clients.matchAll error', error);\n  })\n\n  event.waitUntil(promise);\n});\n\nctx.addEventListener('notificationclose', onCloseNotification);\n\nconst notifications: Set<Notification> = new Set();\nlet pendingNotification: PushNotificationObject;\nfunction pushToNotifications(notification: Notification) {\n  if(!notifications.has(notification)) {\n    notifications.add(notification);\n    // @ts-ignore\n    notification.onclose = onCloseNotification;\n  }\n}\n\nfunction onCloseNotification(event: NotificationEvent) {\n  removeFromNotifications(event.notification)\n}\n\nfunction removeFromNotifications(notification: Notification) {\n  notifications.delete(notification);\n}\n\nexport function closeAllNotifications(tag?: string) {\n  for(const notification of notifications) {\n    try {\n      if(tag && notification.tag !== tag) {\n        continue;\n      }\n\n      notification.close();\n      notifications.delete(notification);\n    } catch(e) {}\n  }\n\n  let promise: Promise<void>;\n  if('getNotifications' in ctx.registration) {\n    promise = ctx.registration.getNotifications({tag}).then((notifications) => {\n      for(let i = 0, len = notifications.length; i < len; ++i) {\n        try {\n          notifications[i].close();\n        } catch(e) {}\n      }\n    }).catch((error) => {\n      log.error('Offline register SW error', error);\n    });\n  } else {\n    promise = Promise.resolve();\n  }\n\n  return promise;\n}\n\nfunction userInvisibleIsSupported() {\n  return IS_FIREFOX;\n}\n\nfunction fireNotification(obj: PushNotificationObject, settings: PushStorage['push_settings'], lang: PushStorage['push_lang']) {\n  let title = obj.title || 'Telegram';\n  let body = obj.description || '';\n  let peerId: string;\n\n  if(obj.custom) {\n    if(obj.custom.channel_id) {\n      peerId = '' + -obj.custom.channel_id;\n    } else if(obj.custom.chat_id) {\n      peerId = '' + -obj.custom.chat_id;\n    } else {\n      peerId = obj.custom.from_id || '';\n    }\n  }\n\n  obj.custom.peerId = '' + peerId;\n  let tag = 'peer' + peerId;\n\n  const messageKey = peerId + '_' + obj.custom.msg_id;\n  if(ignoreMessages.has(messageKey)) {\n    const error = 'ignoring push';\n    log.warn(error, obj);\n    ignoreMessages.delete(messageKey);\n    throw error;\n  }\n\n  if(settings?.nopreview) {\n    title = 'Telegram';\n    body = lang.push_message_nopreview;\n    tag = 'unknown_peer';\n  }\n\n  const actions: (Omit<NotificationAction, 'action'> & {action: PushNotificationObject['action']})[] = [{\n    action: 'mute1d',\n    title: lang.push_action_mute1d\n  }/* , {\n    action: 'push_settings',\n    title: lang.push_action_settings || 'Settings'\n  } */];\n\n  const notificationOptions: NotificationOptions = {\n    body,\n    icon: NOTIFICATION_ICON_PATH,\n    tag,\n    data: obj,\n    actions,\n    badge: NOTIFICATION_BADGE_PATH,\n    silent: obj.custom.silent === '1'\n  };\n\n  log('show notify', title, body, obj, notificationOptions);\n\n  const notificationPromise = ctx.registration.showNotification(title, notificationOptions);\n\n  return notificationPromise.catch((error) => {\n    log.error('Show notification promise', error);\n  });\n}\n\nexport function onPing(payload: ServicePushPingTaskPayload, source?: MessageEventSource) {\n  lastPingTime = Date.now();\n  localNotificationsAvailable = payload.localNotifications;\n\n  if(pendingNotification && source) {\n    serviceMessagePort.invokeVoid('pushClick', pendingNotification, source);\n    pendingNotification = undefined;\n  }\n\n  if(payload.lang) {\n    getter.set('push_lang', payload.lang);\n  }\n\n  if(payload.settings) {\n    getter.set('push_settings', payload.settings);\n  }\n}\n\nconst ignoreMessages: Map<string, number> = new Map();\nexport function onShownNotification(payload: string) {\n  ignoreMessages.set(payload, Date.now());\n}\n\nsetInterval(() => {\n  const time = Date.now();\n  ignoreMessages.forEach((_time, key) => {\n    if((time - _time) > 30e3) {\n      ignoreMessages.delete(key);\n    }\n  });\n}, 30 * 60e3);\n","const tabId = Date.now() % Math.random() * 100000000 | 0;\nexport default tabId;\n","export default function indexOfAndSplice<T>(array: Array<T>, item: T) {\n  const idx = array.indexOf(item);\n  const spliced = idx === -1 ? undefined : array.splice(idx, 1);\n  return spliced?.[0];\n}\n","export default function findAndSplice<T>(array: Array<T>, verify: (value: T, index?: number, array?: Array<T>) => boolean) {\n  const index = array.findIndex(verify);\n  return index !== -1 ? array.splice(index, 1)[0] : undefined;\n};\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n// import { MOUNT_CLASS_TO } from \"../config/debug\";\nimport type {ArgumentTypes, SuperReturnType} from '../types';\nimport findAndSplice from './array/findAndSplice';\n\n// class EventSystem {\n//   wm: WeakMap<any, Record<any, Set<any>>> = new WeakMap();\n\n//   add(target: any, event: any, listener: any) {\n//     let listeners = this.wm.get(target);\n//     if (listeners === undefined) {\n//         listeners = {};\n//     }\n//     let listenersForEvent = listeners[event];\n//     if (listenersForEvent === undefined) {\n//         listenersForEvent = new Set();\n//     }\n//     listenersForEvent.add(listener);\n//     listeners[event] = listenersForEvent;\n//     //target.addEventListener(event, listener);\n//     this.wm.set(target, listeners);\n//   };\n\n//   remove(target: any, event: any, listener: any) {\n//     let listeners = this.wm.get(target);\n//     if (!listeners) return;\n//     let listenersForEvent = listeners[event];\n//     if (!listenersForEvent) return;\n//     listenersForEvent.delete(listener);\n//   };\n\n//   /* fire(target, event) {\n//      let listeners = this.wm.get(target);\n//      if (!listeners) return;\n//      let listenersForEvent = listeners[event];\n//      if (!listenersForEvent) return;\n//      for (let handler of handlers) {\n//          setTimeout(handler, 0, event, target); // we use a setTimeout here because we want event triggering to be asynchronous.\n//      }\n//   }; */\n// }\n\n// console.log = () => {};\n\n// const e = new EventSystem();\n// MOUNT_CLASS_TO.e = e;\n\nexport type EventListenerListeners = Record<string, Function>;\n// export type EventListenerListeners = Record<string, (...args: any[]) => any>;\n// export type EventListenerListeners = {[name in string]: Function};\n\n/**\n * Better not to remove listeners during setting\n * Should add listener callback only once\n */\n\ntype ListenerObject<T> = {callback: T, options: boolean | AddEventListenerOptions};\n\n// type EventLitenerCallback<T> = (data: T) =>\n// export default class EventListenerBase<Listeners extends {[name: string]: Function}> {\nexport default class EventListenerBase<Listeners extends EventListenerListeners> {\n  protected listeners: Partial<{\n    [k in keyof Listeners]: Array<ListenerObject<Listeners[k]>>\n  }>;\n  protected listenerResults: Partial<{\n    [k in keyof Listeners]: ArgumentTypes<Listeners[k]>\n  }>;\n\n  private reuseResults: boolean;\n\n  constructor(reuseResults?: boolean) {\n    this._constructor(reuseResults);\n  }\n\n  public _constructor(reuseResults?: boolean): any {\n    this.reuseResults = reuseResults;\n    this.listeners = {};\n    this.listenerResults = {};\n  }\n\n  public addEventListener<T extends keyof Listeners>(name: T, callback: Listeners[T], options?: boolean | AddEventListenerOptions) {\n    (this.listeners[name] ??= []).push({callback, options}); // ! add before because if you don't, you won't be able to delete it from callback\n\n    if(this.listenerResults.hasOwnProperty(name)) {\n      callback(...this.listenerResults[name]);\n\n      if((options as AddEventListenerOptions)?.once) {\n        this.listeners[name].pop();\n        return;\n      }\n    }\n\n    // e.add(this, name, {callback, once});\n  }\n\n  public addMultipleEventsListeners(obj: {\n    [name in keyof Listeners]?: Listeners[name]\n  }) {\n    for(const i in obj) {\n      this.addEventListener(i, obj[i]);\n    }\n  }\n\n  public removeEventListener<T extends keyof Listeners>(\n    name: T,\n    callback: Listeners[T],\n    options?: boolean | AddEventListenerOptions\n  ) {\n    if(this.listeners[name]) {\n      findAndSplice(this.listeners[name], (l) => l.callback === callback);\n    }\n    // e.remove(this, name, callback);\n  }\n\n  protected invokeListenerCallback<T extends keyof Listeners, L extends ListenerObject<any>>(\n    name: T,\n    listener: L,\n    ...args: ArgumentTypes<L['callback']>\n  ) {\n    let result: any, error: any;\n    try {\n      result = listener.callback(...args);\n    } catch(err) {\n      error = err;\n      // console.error('listener callback error', err);\n    }\n\n    if((listener.options as AddEventListenerOptions)?.once) {\n      this.removeEventListener(name, listener.callback);\n    }\n\n    if(error) {\n      throw error;\n    }\n\n    return result;\n  }\n\n  private _dispatchEvent<T extends keyof Listeners>(\n    name: T,\n    collectResults: boolean,\n    ...args: ArgumentTypes<Listeners[T]>\n  ) {\n    if(this.reuseResults) {\n      this.listenerResults[name] = args;\n    }\n\n    const arr: Array<SuperReturnType<Listeners[typeof name]>> = collectResults && [];\n\n    const listeners = this.listeners[name];\n    if(listeners) {\n      // ! this one will guarantee execution even if delete another listener during setting\n      const left = listeners.slice();\n      left.forEach((listener) => {\n        const index = listeners.findIndex((l) => l.callback === listener.callback);\n        if(index === -1) {\n          return;\n        }\n\n        const result = this.invokeListenerCallback(name, listener, ...args);\n        if(arr) {\n          arr.push(result);\n        }\n      });\n    }\n\n    return arr;\n  }\n\n  public dispatchResultableEvent<T extends keyof Listeners>(name: T, ...args: ArgumentTypes<Listeners[T]>) {\n    return this._dispatchEvent(name, true, ...args);\n  }\n\n  // * must be protected, but who cares\n  public dispatchEvent<L extends EventListenerListeners = Listeners, T extends keyof L = keyof L>(\n    name: T,\n    ...args: ArgumentTypes<L[T]>\n  ) {\n    // @ts-ignore\n    this._dispatchEvent(name, false, ...args);\n  }\n\n  public cleanup() {\n    this.listeners = {};\n    this.listenerResults = {};\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport DEBUG from '../../config/debug';\nimport tabId from '../../config/tabId';\nimport ctx from '../../environment/ctx';\nimport indexOfAndSplice from '../../helpers/array/indexOfAndSplice';\nimport {IS_WORKER} from '../../helpers/context';\nimport EventListenerBase from '../../helpers/eventListenerBase';\nimport makeError from '../../helpers/makeError';\nimport {Awaited, WorkerTaskTemplate, WorkerTaskVoidTemplate} from '../../types';\nimport {logger} from '../logger';\n\ntype SuperMessagePortTask = WorkerTaskTemplate & {\n  transfer?: Transferable[]\n};\n\ninterface InvokeTask extends SuperMessagePortTask {\n  type: 'invoke',\n  payload: WorkerTaskVoidTemplate & {withAck?: boolean, void?: boolean}\n}\n\ninterface ResultTask extends SuperMessagePortTask {\n  type: 'result',\n  payload: {\n    taskId: number,\n    result?: any,\n    error?: any\n  }\n}\n\ninterface AckTask extends SuperMessagePortTask {\n  type: 'ack',\n  payload: {\n    cached: boolean,\n    taskId: number\n    result?: any,\n    error?: any,\n  }\n}\n\ninterface PingTask extends SuperMessagePortTask {\n  type: 'ping'\n}\n\ninterface PongTask extends SuperMessagePortTask {\n  type: 'pong'\n}\n\ninterface BatchTask extends SuperMessagePortTask {\n  type: 'batch',\n  payload: Task[]\n}\n\ninterface CloseTask extends SuperMessagePortTask {\n  type: 'close'\n}\n\n// interface OpenTask extends SuperMessagePortTask {\n//   type: 'open'\n// }\n\ninterface LockTask extends SuperMessagePortTask {\n  type: 'lock',\n  payload: string\n}\n\ntype Task = InvokeTask | ResultTask | AckTask | PingTask | PongTask | BatchTask | CloseTask/*  | OpenTask */ | LockTask;\ntype TaskMap = {\n  [type in Task as type['type']]?: (task: Extract<Task, type>, source: MessageEventSource, event: MessageEvent<any>) => void | Promise<any>\n};\n\nexport type AckedResult<T> = {\n  cached: boolean,\n  result: Promise<T>\n};\n// export type AckedResult<T> = {\n//   cached: true,\n//   result: T\n// } | {\n//   cached: false,\n//   result: Promise<T>\n// };\n\ntype ListenPort = WindowProxy | MessagePort | ServiceWorker | Worker | ServiceWorkerContainer;\ntype SendPort = Pick<MessageEventSource, 'postMessage'>/* WindowProxy | MessagePort | ServiceWorker | Worker */;\n\nexport type MessageListenPort = ListenPort;\nexport type MessageSendPort = SendPort;\n\ntype ListenerCallback = (payload: any, source: MessageEventSource, event: MessageEvent<any>) => any;\ntype Listeners = Record<string, ListenerCallback>;\n\nconst USE_LOCKS = true;\n\n// const PING_INTERVAL = DEBUG && false ? 0x7FFFFFFF : 5000;\n// const PING_TIMEOUT = DEBUG && false ? 0x7FFFFFFF : 10000;\n\nexport default class SuperMessagePort<\n  Workers extends Listeners,\n  Masters extends Listeners,\n  IsMaster extends boolean,\n  Receive extends Listeners = IsMaster extends true ? Masters : Workers,\n  Send extends Listeners = IsMaster extends true ? Workers : Masters\n> extends EventListenerBase<Receive> {\n  protected listenPorts: Array<ListenPort>;\n  protected sendPorts: Array<SendPort>;\n  protected pingResolves: Map<SendPort, () => void>;\n\n  protected taskId: number;\n  protected awaiting: {\n    [id: number]: {\n      resolve: any,\n      reject: any,\n      taskType: string,\n      port?: SendPort\n    }\n  };\n  protected pending: Map<SendPort, Task[]>;\n\n  protected log: ReturnType<typeof logger>;\n  protected debug: boolean;\n  protected releasingPending: boolean;\n\n  protected processTaskMap: TaskMap;\n\n  protected onPortDisconnect: (source: MessageEventSource) => void;\n  // protected onPortConnect: (source: MessageEventSource) => void;\n\n  protected heldLocks: Map<SendPort, {resolve: () => void, id: string}>;\n  protected requestedLocks: Map<string, SendPort>;\n\n  constructor(protected logSuffix?: string) {\n    super(false);\n\n    this.listenPorts = [];\n    this.sendPorts = [];\n    this.pingResolves = new Map();\n    this.taskId = 0;\n    this.awaiting = {};\n    this.pending = new Map();\n    this.log = logger('MP' + (logSuffix ? '-' + logSuffix : ''));\n    this.debug = DEBUG;\n    this.heldLocks = new Map();\n    this.requestedLocks = new Map();\n\n    this.processTaskMap = {\n      result: this.processResultTask,\n      ack: this.processAckTask,\n      invoke: this.processInvokeTask,\n      ping: this.processPingTask,\n      pong: this.processPongTask,\n      close: this.processCloseTask,\n      // open: this.processOpenTask,\n      lock: this.processLockTask\n    };\n  }\n\n  public setOnPortDisconnect(callback: (source: MessageEventSource) => void) {\n    this.onPortDisconnect = callback;\n  }\n\n  // public setOnPortConnect(callback: (source: MessageEventSource) => void) {\n  //   this.onPortConnect = callback;\n  // }\n\n  public attachPort(port: MessageEventSource) {\n    this.attachListenPort(port);\n    this.attachSendPort(port);\n  }\n\n  public attachListenPort(port: ListenPort) {\n    this.listenPorts.push(port);\n    port.addEventListener('message', this.onMessage as any);\n  }\n\n  public attachSendPort(port: SendPort) {\n    this.log.warn('attaching send port');\n\n    (port as MessagePort).start?.();\n\n    this.sendPorts.push(port);\n    // this.sendPing(port);\n\n    // const task = this.createTask('open', undefined);\n    // this.postMessage(port, task);\n\n    if(typeof(window) !== 'undefined' && USE_LOCKS) {\n      if('locks' in navigator) {\n        const id = ['lock', tabId, this.logSuffix || '', Math.random() * 0x7FFFFFFF | 0].join('-');\n        this.log.warn('created lock', id);\n        const promise = new Promise<void>((resolve) => this.heldLocks.set(port, {resolve, id}))\n        .then(() => this.heldLocks.delete(port));\n        navigator.locks.request(id, () => {\n          this.resendLockTask(port);\n          return promise;\n        });\n      } else {\n        window.addEventListener('beforeunload', () => {\n          const task = this.createTask('close', undefined);\n          this.postMessage(undefined, task);\n        });\n      }\n    }\n\n    this.releasePending();\n  }\n\n  public resendLockTask(port: SendPort) {\n    const lock = this.heldLocks.get(port);\n    if(!lock) {\n      return;\n    }\n\n    this.pushTask(this.createTask('lock', lock.id), port);\n  }\n\n  // ! Can't rely on ping because timers can be suspended\n  // protected sendPing(port: SendPort, loop = IS_WORKER) {\n  //   let timeout: number;\n  //   const promise = new Promise<void>((resolve, reject) => {\n  //     this.pingResolves.set(port, resolve);\n  //     this.pushTask(this.createTask('ping', undefined), port);\n\n  //     timeout = ctx.setTimeout(() => {\n  //       reject();\n  //     }, PING_TIMEOUT);\n  //   });\n\n  //   promise.then(() => {\n  //     // this.log('got pong');\n\n  //     clearTimeout(timeout);\n  //     this.pingResolves.delete(port);\n\n  //     if(loop) {\n  //       this.sendPingWithTimeout(port);\n  //     }\n  //   }, () => {\n  //     this.pingResolves.delete(port);\n  //     this.detachPort(port);\n  //   });\n  // }\n\n  // protected sendPingWithTimeout(port: SendPort, timeout = PING_INTERVAL) {\n  //   ctx.setTimeout(() => {\n  //     if(!this.sendPorts.includes(port)) {\n  //       return;\n  //     }\n\n  //     this.sendPing(port);\n  //   }, timeout);\n  // }\n\n  public detachPort(port: ListenPort) {\n    this.log.warn('disconnecting port');\n\n    indexOfAndSplice(this.listenPorts, port);\n    indexOfAndSplice(this.sendPorts, port as any);\n\n    port.removeEventListener?.('message', this.onMessage as any);\n    (port as MessagePort).close?.();\n\n    this.onPortDisconnect?.(port as any);\n\n    const heldLock = this.heldLocks.get(port as SendPort);\n    heldLock?.resolve();\n\n    const error = makeError('PORT_DISCONNECTED');\n    for(const id in this.awaiting) {\n      const task = this.awaiting[id];\n      if(task.port === port) {\n        task.reject(error);\n        delete this.awaiting[id];\n      }\n    }\n  }\n\n  protected postMessage(port: SendPort | SendPort[], task: Task) {\n    const ports = Array.isArray(port) ? port : (port ? [port] : this.sendPorts);\n    ports.forEach((port) => {\n      port.postMessage(task, task.transfer as any);\n    });\n  }\n\n  protected onMessage = (event: MessageEvent) => {\n    const task: Task = event.data;\n    // this.log('got message', task);\n\n    const source: MessageEventSource = event.source || event.currentTarget as any; // can have no source\n    /* if(task.type === 'batch') {\n      const newEvent: MessageEvent = {data: event.data, source: event.source, currentTarget: event.currentTarget} as any;\n      task.payload.forEach((task) => {\n        // @ts-ignore\n        newEvent.data = task;\n        this.onMessage(newEvent);\n      });\n    } */\n\n    // @ts-ignore\n    this.processTaskMap[task.type](task, source, event);\n  };\n\n  protected /* async */ releasePending() {\n    // return;\n\n    if(/* !this.listenPorts.length || !this.sendPorts.length ||  */this.releasingPending) {\n      return;\n    }\n\n    this.releasingPending = true;\n    // const perf = performance.now();\n    // await pause(0);\n\n    this.debug && this.log.debug('releasing tasks, length:', this.pending.size/* , performance.now() - perf */);\n\n    this.pending.forEach((portTasks, port) => {\n      // let batchTask: BatchTask;\n      // const tasks: Task[] = [];\n      // portTasks.forEach((task) => {\n      //   if(task.transfer) {\n      //     batchTask = undefined;\n      //     tasks.push(task);\n      //   } else {\n      //     if(!batchTask) {\n      //       batchTask = this.createTask('batch', []);\n      //       tasks.push(batchTask);\n      //     }\n\n      //     batchTask.payload.push(task);\n      //   }\n      // });\n\n      const tasks = portTasks;\n      const ports = port ? [port] : this.sendPorts;\n      if(!ports.length) {\n        return;\n      }\n\n      tasks.forEach((task) => {\n        // if(task.type === 'batch') {\n        //   this.log(`batching ${task.payload.length} tasks`);\n        // }\n\n        try {\n          // if(IS_SERVICE_WORKER && !port) {\n          //   notifyAll(task);\n          // } else {\n          this.postMessage(ports, task);\n          // }\n        } catch(err) {\n          this.log.error('postMessage error:', err, task, ports);\n        }\n      });\n\n      this.pending.delete(port);\n    });\n\n    this.debug && this.log.debug('released tasks');\n\n    this.releasingPending = false;\n  }\n\n  protected processResultTask = (task: ResultTask) => {\n    const {taskId, result, error} = task.payload;\n    const deferred = this.awaiting[taskId];\n    if(!deferred) {\n      return;\n    }\n\n    this.debug && this.log.debug('done', deferred.taskType, result, error);\n    'error' in task.payload ? deferred.reject(error) : deferred.resolve(result);\n    delete this.awaiting[taskId];\n  };\n\n  protected processAckTask = (task: AckTask) => {\n    const payload = task.payload;\n    const deferred = this.awaiting[payload.taskId];\n    if(!deferred) {\n      return;\n    }\n\n    // * will finish the init promise with incoming result\n    const previousResolve: (acked: AckedResult<any>) => void = deferred.resolve;\n    // const previousReject = deferred.reject;\n\n    // if(payload.cached) {\n    //   if('result' in payload) {\n    //     previousResolve({\n    //       cached: true,\n    //       result: payload.result\n    //     });\n    //   } else {\n    //     previousReject(payload.error);\n    //   }\n    // } else {\n    //   const ret: AckedResult<any> = {\n    //     cached: false,\n    //     result: new Promise((resolve, reject) => {\n    //       deferred.resolve = resolve;\n    //       deferred.reject = reject;\n    //     })\n    //   };\n\n    //   previousResolve(ret);\n    // }\n\n    const ret: AckedResult<any> = {\n      cached: payload.cached,\n      result: payload.cached ? ('result' in payload ? Promise.resolve(payload.result) : Promise.reject(payload.error)) : new Promise((resolve, reject) => {\n        deferred.resolve = resolve;\n        deferred.reject = reject;\n      })\n    };\n\n    previousResolve(ret);\n\n    if(payload.cached) {\n      delete this.awaiting[payload.taskId];\n    }\n  };\n\n  protected processPingTask = (task: PingTask, source: MessageEventSource, event: MessageEvent) => {\n    this.pushTask(this.createTask('pong', undefined), event.source);\n  };\n\n  protected processPongTask = (task: PongTask, source: MessageEventSource, event: MessageEvent) => {\n    const pingResolve = this.pingResolves.get(source);\n    if(pingResolve) {\n      this.pingResolves.delete(source);\n      pingResolve();\n    }\n  };\n\n  protected processCloseTask = (task: CloseTask, source: MessageEventSource, event: MessageEvent) => {\n    this.detachPort(source);\n  };\n\n  // * it's just an 'open' callback, DO NOT attach port from here\n  // protected processOpenTask = (task: OpenTask, source: MessageEventSource, event: MessageEvent) => {\n  //   this.onPortConnect?.(source);\n  // };\n\n  protected processLockTask = (task: LockTask, source: MessageEventSource, event: MessageEvent) => {\n    const id = task.payload;\n    if(this.requestedLocks.has(id)) {\n      return;\n    }\n\n    this.requestedLocks.set(id, source);\n    navigator.locks.request(id, () => {\n      this.processCloseTask(undefined, source, undefined);\n      this.requestedLocks.delete(id);\n    });\n  };\n\n  protected processInvokeTask = async(task: InvokeTask, source: MessageEventSource, event: MessageEvent) => {\n    const id = task.id;\n    const innerTask = task.payload;\n\n    let resultTaskPayload: ResultTask['payload'];\n    let resultTask: ResultTask, ackTask: AckTask;\n    if(!innerTask.void) {\n      resultTaskPayload = {taskId: id};\n      resultTask = this.createTask('result', resultTaskPayload);\n    }\n\n    if(innerTask.withAck) {\n      ackTask = this.createTask('ack', {\n        taskId: id,\n        cached: true\n      });\n    }\n\n    let isPromise: boolean;\n    try {\n      const listeners = this.listeners[innerTask.type];\n      if(!listeners?.length) {\n        throw new Error('no listener');\n      }\n\n      const listener = listeners[0];\n\n      // @ts-ignore\n      let result = this.invokeListenerCallback(innerTask.type, listener, innerTask.payload, source, event);\n      if(innerTask.void) {\n        return;\n      }\n\n      isPromise = result instanceof Promise;\n\n      if(ackTask) {\n        const cached = !isPromise;\n        ackTask.payload.cached = cached;\n        if(cached) ackTask.payload.result = result;\n        this.pushTask(ackTask, source);\n\n        if(cached) {\n          return;\n        }\n      }\n\n      if(isPromise) {\n        result = await result;\n      }\n\n      resultTaskPayload.result = result;\n    } catch(error) {\n      this.log.error('worker task error:', error, task);\n      if(innerTask.void) {\n        return;\n      }\n\n      if(ackTask && ackTask.payload.cached) {\n        ackTask.payload.error = error;\n        this.pushTask(ackTask, source);\n        return;\n      }\n\n      resultTaskPayload.error = error;\n    }\n\n    this.pushTask(resultTask, source);\n  };\n\n  protected createTask<T extends Task['type'], K extends Task = Parameters<TaskMap[T]>[0]>(type: T, payload: K['payload'], transfer?: Transferable[]): K {\n    return {\n      type,\n      payload,\n      id: this.taskId++,\n      transfer\n    } as K;\n  }\n\n  protected createInvokeTask(type: string, payload: any, withAck?: boolean, _void?: boolean, transfer?: Transferable[]): InvokeTask {\n    return this.createTask('invoke', {\n      type,\n      payload,\n      withAck,\n      void: _void\n    }, transfer);\n  }\n\n  protected pushTask(task: Task, port?: SendPort) {\n    let tasks = this.pending.get(port);\n    if(!tasks) {\n      this.pending.set(port, tasks = []);\n    }\n\n    tasks.push(task);\n    this.releasePending();\n  }\n\n  public invokeVoid<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], port?: SendPort, transfer?: Transferable[]) {\n    const task = this.createInvokeTask(type as string, payload, undefined, true, transfer);\n    this.pushTask(task, port);\n  }\n\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: false, port?: SendPort, transfer?: Transferable[]): Promise<Awaited<ReturnType<Send[T]>>>;\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: true, port?: SendPort, transfer?: Transferable[]): Promise<AckedResult<Awaited<ReturnType<Send[T]>>>>;\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: boolean, port?: SendPort, transfer?: Transferable[]) {\n    this.debug && this.log.debug('start', type, payload);\n\n    let task: InvokeTask;\n    const promise = new Promise<Awaited<ReturnType<Send[T]>>>((resolve, reject) => {\n      task = this.createInvokeTask(type as string, payload, withAck, undefined, transfer);\n      this.awaiting[task.id] = {resolve, reject, taskType: type as string, port};\n      this.pushTask(task, port);\n    });\n\n    if(IS_WORKER) {\n      promise.finally(() => {\n        clearInterval(interval);\n      });\n\n      const interval = ctx.setInterval(() => {\n        this.log.error('task still has no result', task, port);\n      }, 60e3);\n    } else if(false) {\n      // let timedOut = false;\n      const startTime = Date.now();\n      promise.finally(() => {\n        const elapsedTime = Date.now() - startTime;\n        if(elapsedTime >= TIMEOUT) {\n          this.log.error(`task was processing ${Date.now() - startTime}ms`, task.payload.payload, port);\n        }/*  else {\n          clearTimeout(timeout);\n        } */\n      });\n\n      const TIMEOUT = 10;\n      // const timeout = ctx.setTimeout(() => {\n      //   timedOut = true;\n      //   // this.log.error(`task is processing more than ${TIMEOUT} milliseconds`, task, port);\n      // }, TIMEOUT);\n    }\n\n    return promise;\n  }\n\n  public invokeExceptSource<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], source?: SendPort) {\n    const ports = this.sendPorts.slice();\n    indexOfAndSplice(ports, source);\n\n    ports.forEach((target) => {\n      this.invokeVoid(type, payload, target);\n    });\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type {WebPushApiManager} from '../mtproto/webPushApiManager';\nimport type {PushNotificationObject} from './push';\nimport type {MyUploadFile} from '../mtproto/apiFileManager';\nimport SuperMessagePort from '../mtproto/superMessagePort';\nimport {MOUNT_CLASS_TO} from '../../config/debug';\n\nexport type ServicePushPingTaskPayload = {\n  localNotifications: boolean,\n  lang: {\n    push_action_mute1d: string\n    push_action_settings: string\n    push_message_nopreview: string\n  },\n  settings: WebPushApiManager['settings']\n};\n\nexport type ServiceRequestFilePartTaskPayload = {\n  docId: DocId,\n  dcId: number,\n  offset: number,\n  limit: number\n};\n\nexport type ServiceDownloadTaskPayload = {\n  headers: any,\n  id: string\n};\n\nexport type ServiceEvent = {\n  port: (payload: void, source: MessageEventSource, event: MessageEvent) => void\n};\n\nexport default class ServiceMessagePort<Master extends boolean = false> extends SuperMessagePort<{\n  // from main thread to service worker\n  notificationsClear: () => void,\n  toggleStorages: (payload: {enabled: boolean, clearWrite: boolean}) => void,\n  pushPing: (payload: ServicePushPingTaskPayload, source: MessageEventSource, event: MessageEvent) => void,\n  hello: (payload: void, source: MessageEventSource, event: MessageEvent) => void,\n  shownNotification: (payload: string) => void,\n\n  // from mtproto worker\n  download: (payload: ServiceDownloadTaskPayload) => void,\n  downloadChunk: (payload: {id: ServiceDownloadTaskPayload['id'], chunk: Uint8Array}) => void\n  downloadFinalize: (payload: ServiceDownloadTaskPayload['id']) => void,\n  downloadCancel: (payload: ServiceDownloadTaskPayload['id']) => void\n}, {\n  // to main thread\n  pushClick: (payload: PushNotificationObject) => void,\n  hello: (payload: void, source: MessageEventSource) => void,\n  share: (payload: ShareData) => void,\n\n  // to mtproto worker\n  requestFilePart: (payload: ServiceRequestFilePartTaskPayload) => Promise<MyUploadFile> | MyUploadFile\n} & ServiceEvent, Master> {\n  constructor() {\n    super('SERVICE');\n\n    MOUNT_CLASS_TO && (MOUNT_CLASS_TO.serviceMessagePort = this);\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type SuperMessagePort from '../lib/mtproto/superMessagePort';\nimport ctx from '../environment/ctx';\n\nexport default function listenMessagePort(\n  messagePort: SuperMessagePort<any, any, any>,\n  onConnect?: (source: MessageEventSource) => void,\n  onDisconnect?: (source: MessageEventSource) => void\n) {\n  const attachPort = (listenPort: any, sendPort: any) => {\n    messagePort.attachListenPort(listenPort);\n    sendPort && messagePort.attachSendPort(sendPort);\n    onConnect?.(listenPort);\n  };\n\n  messagePort.setOnPortDisconnect(onDisconnect);\n\n  if(typeof(SharedWorkerGlobalScope) !== 'undefined') {\n    (ctx as any as SharedWorkerGlobalScope).addEventListener('connect', (e) => attachPort(e.source, e.source));\n  } else if(typeof(ServiceWorkerGlobalScope) !== 'undefined') {\n    attachPort(ctx, null);\n  } else {\n    attachPort(ctx, ctx);\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type {ServiceDownloadTaskPayload} from './serviceMessagePort';\nimport type ServiceMessagePort from './serviceMessagePort';\nimport deferredPromise, {CancellablePromise} from '../../helpers/cancellablePromise';\nimport makeError from '../../helpers/makeError';\nimport pause from '../../helpers/schedulers/pause';\n\ntype DownloadType = Uint8Array;\ntype DownloadItem = ServiceDownloadTaskPayload & {\n  // transformStream: TransformStream<DownloadType, DownloadType>,\n  readableStream: ReadableStream<DownloadType>,\n  // writableStream: WritableStream<DownloadType>,\n  // writer: WritableStreamDefaultWriter<DownloadType>,\n  // controller: TransformStreamDefaultController<DownloadType>,\n  controller: ReadableStreamController<Uint8Array>,\n  promise: CancellablePromise<void>,\n  // downloadPromise: Promise<void>,\n  used?: boolean\n};\nconst downloadMap: Map<string, DownloadItem> = new Map();\nconst DOWNLOAD_ERROR = makeError('UNKNOWN');\nconst DOWNLOAD_TEST = false;\n\n(self as any).downloadMap = downloadMap;\n\ntype A = Parameters<ServiceMessagePort<false>['addMultipleEventsListeners']>[0];\n\nconst events: A = {\n  download: (payload) => {\n    const {id} = payload;\n    if(downloadMap.has(id)) {\n      return Promise.reject(DOWNLOAD_ERROR);\n    }\n\n    // const y = (20 * 1024 * 1024) / payload.limitPart;\n    // const strategy = new ByteLengthQueuingStrategy({highWaterMark: y});\n    // let controller: TransformStreamDefaultController<DownloadType>;\n    const strategy = new CountQueuingStrategy({highWaterMark: 1});\n    // const transformStream = new TransformStream<DownloadType, DownloadType>(/* {\n    //   start: (_controller) => controller = _controller,\n    // },  */undefined, strategy, strategy);\n\n    // const {readable, writable} = transformStream;\n    // const writer = writable.getWriter();\n\n    const promise = deferredPromise<void>();\n    promise.then(() => {\n      setTimeout(() => {\n        downloadMap.delete(id);\n      }, 5e3);\n    }, () => {\n      downloadMap.delete(id);\n    });\n\n    // writer.closed.then(promise.resolve, promise.reject);\n\n    let controller: ReadableStreamController<any>;\n    const readable = new ReadableStream({\n      start: (_controller) => {\n        controller = _controller;\n      },\n\n      cancel: (reason) => {\n        promise.reject(DOWNLOAD_ERROR);\n      }\n    }, strategy);\n\n    // writer.closed.catch(noop).finally(() => {\n    //   log.error('closed writer');\n    //   onEnd();\n    // });\n\n    // const downloadPromise = writer.closed.catch(() => {throw DOWNLOAD_ERROR;});\n    const item: DownloadItem = {\n      ...payload,\n      // transformStream,\n      readableStream: readable,\n      // writableStream: writable,\n      // writer,\n      // downloadPromise,\n      promise,\n      controller\n    };\n\n    downloadMap.set(id, item);\n\n    // return downloadPromise;\n    return promise.catch(() => {throw DOWNLOAD_ERROR});\n  },\n\n  downloadChunk: ({id, chunk}) => {\n    const item = downloadMap.get(id);\n    if(!item) {\n      return Promise.reject();\n    }\n\n    // return item.controller.enqueue(chunk);\n    // return item.writer.write(chunk);\n    // @ts-ignore\n    return item.controller.enqueue(chunk);\n  },\n\n  downloadFinalize: (id) => {\n    const item = downloadMap.get(id);\n    if(!item) {\n      return Promise.reject();\n    }\n\n    item.promise.resolve();\n    // return item.controller.terminate();\n    // return item.writer.close();\n    return item.controller.close();\n  },\n\n  downloadCancel: (id) => {\n    const item = downloadMap.get(id);\n    if(!item) {\n      return;\n    }\n\n    item.promise.reject();\n    // return item.controller.error();\n    // return item.writer.abort();\n    return item.controller.error();\n  }\n};\n\nexport default function handleDownload(serviceMessagePort: ServiceMessagePort<false>) {\n  serviceMessagePort.addMultipleEventsListeners(events);\n\n  return {\n    onDownloadFetch,\n    onClosedWindows: cancelAllDownloads\n  };\n}\n\nfunction onDownloadFetch(event: FetchEvent, params: string) {\n  const promise = pause(100).then(() => {\n    const item = downloadMap.get(params);\n    if(!item || (item.used && !DOWNLOAD_TEST)) {\n      return;\n    }\n\n    item.used = true;\n    const stream = item.readableStream;\n    const response = new Response(stream, {headers: item.headers});\n    return response;\n  });\n\n  event.respondWith(promise);\n}\n\nfunction cancelAllDownloads() {\n  if(downloadMap.size) {\n    for(const [id, item] of downloadMap) {\n      // item.writer.abort().catch(noop);\n      item.controller.error();\n    }\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport {log, serviceMessagePort} from './index.service';\n\nconst deferred: {[id: string]: ShareData[]} = {};\n\nfunction parseFormData(formData: FormData): ShareData {\n  return {\n    files: formData.getAll('files') as File[],\n    title: formData.get('title') as string,\n    text: formData.get('text') as string,\n    url: formData.get('url') as string\n  };\n}\n\nasync function processShareEvent(formData: FormData, clientId: string) {\n  try {\n    log('share data', formData);\n    const data = parseFormData(formData);\n    (deferred[clientId] ??= []).push(data);\n  } catch(err) {\n    log.warn('something wrong with the data', err);\n  }\n};\n\nexport function checkWindowClientForDeferredShare(windowClient: WindowClient) {\n  const arr = deferred[windowClient.id];\n  if(!arr) {\n    return;\n  }\n\n  delete deferred[windowClient.id];\n\n  log('releasing share events to client:', windowClient.id, 'length:', arr.length);\n  arr.forEach((data) => {\n    serviceMessagePort.invokeVoid('share', data, windowClient);\n  });\n}\n\nexport default function onShareFetch(event: FetchEvent, params: string) {\n  const promise = event.request.formData()\n  .then((formData) => {\n    processShareEvent(formData, event.resultingClientId)\n    return Response.redirect('..');\n  });\n\n  event.respondWith(promise);\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport {logger, LogTypes} from '../logger';\nimport {CACHE_ASSETS_NAME, requestCache} from './cache';\nimport onStreamFetch from './stream';\nimport {closeAllNotifications, onPing, onShownNotification} from './push';\nimport CacheStorageController from '../files/cacheStorage';\nimport {IS_SAFARI} from '../../environment/userAgent';\nimport ServiceMessagePort from './serviceMessagePort';\nimport listenMessagePort from '../../helpers/listenMessagePort';\nimport {getWindowClients} from '../../helpers/context';\nimport {MessageSendPort} from '../mtproto/superMessagePort';\nimport handleDownload from './download';\nimport onShareFetch, {checkWindowClientForDeferredShare} from './share';\n\n// #if MTPROTO_SW\n// import '../mtproto/mtproto.worker';\n// #endif\n\nexport const log = logger('SW', LogTypes.Error | LogTypes.Debug | LogTypes.Log | LogTypes.Warn, true);\nconst ctx = self as any as ServiceWorkerGlobalScope;\n\n// #if !MTPROTO_SW\nlet _mtprotoMessagePort: MessagePort;\nexport const getMtprotoMessagePort = () => _mtprotoMessagePort;\n\nlog('init');\n\nconst sendMessagePort = (source: MessageSendPort) => {\n  const channel = new MessageChannel();\n  serviceMessagePort.attachPort(_mtprotoMessagePort = channel.port1);\n  serviceMessagePort.invokeVoid('port', undefined, source, [channel.port2]);\n};\n\nconst sendMessagePortIfNeeded = (source: MessageSendPort) => {\n  if(!connectedWindows.size && !_mtprotoMessagePort) {\n    log('sending message port for mtproto');\n    sendMessagePort(source);\n  }\n};\n\nconst onWindowConnected = (source: WindowClient) => {\n  log('window connected', source.id, 'windows before', connectedWindows.size);\n\n  if(source.frameType === 'none') {\n    log.warn('maybe a bugged Safari starting window', source.id);\n    return;\n  }\n\n  log('windows', Array.from(connectedWindows));\n  serviceMessagePort.invokeVoid('hello', undefined, source);\n  sendMessagePortIfNeeded(source);\n  connectedWindows.set(source.id, source);\n\n  checkWindowClientForDeferredShare(source);\n};\n\nexport const serviceMessagePort = new ServiceMessagePort<false>();\nserviceMessagePort.addMultipleEventsListeners({\n  notificationsClear: closeAllNotifications,\n\n  toggleStorages: ({enabled, clearWrite}) => {\n    CacheStorageController.toggleStorage(enabled, clearWrite);\n  },\n\n  pushPing: (payload, source) => {\n    onPing(payload, source);\n  },\n\n  hello: (payload, source) => {\n    onWindowConnected(source as any as WindowClient);\n  },\n\n  shownNotification: onShownNotification\n});\n\nconst {\n  onDownloadFetch,\n  onClosedWindows: onDownloadClosedWindows\n} = handleDownload(serviceMessagePort);\n\n// * service worker can be killed, so won't get 'hello' event\ngetWindowClients().then((windowClients) => {\n  log(`got ${windowClients.length} windows from the start`);\n  windowClients.forEach((windowClient) => {\n    onWindowConnected(windowClient);\n  });\n});\n\nconst connectedWindows: Map<string, WindowClient> = new Map();\n(self as any).connectedWindows = connectedWindows;\nlistenMessagePort(serviceMessagePort, undefined, (source) => {\n  log('something has disconnected', source);\n  const isWindowClient = source instanceof WindowClient;\n  if(!isWindowClient || !connectedWindows.has(source.id)) {\n    log.warn('it is not a window');\n    return;\n  }\n\n  connectedWindows.delete(source.id);\n  log('window disconnected, left', connectedWindows.size);\n  if(!connectedWindows.size) {\n    log.warn('no windows left');\n\n    if(_mtprotoMessagePort) {\n      serviceMessagePort.detachPort(_mtprotoMessagePort);\n      _mtprotoMessagePort = undefined;\n    }\n\n    onDownloadClosedWindows();\n  }\n});\n// #endif\n\nconst onFetch = (event: FetchEvent): void => {\n  if(\n    import.meta.env.PROD &&\n    !IS_SAFARI &&\n    event.request.url.indexOf(location.origin + '/') === 0 &&\n    event.request.url.match(/\\.(js|css|jpe?g|json|wasm|png|mp3|svg|tgs|ico|woff2?|ttf|webmanifest?)(?:\\?.*)?$/)\n  ) {\n    return event.respondWith(requestCache(event));\n  }\n\n  if(import.meta.env.DEV && event.request.url.endsWith('.ts')) {\n    return;\n  }\n\n  try {\n    // const [, url, scope, params] = /http[:s]+\\/\\/.*?(\\/(.*?)(?:$|\\/(.*)$))/.exec(event.request.url) || [];\n    const [scope, params] = event.request.url.split('/').slice(-2);\n\n    // log.debug('[fetch]:', event);\n\n    switch(scope) {\n      case 'stream': {\n        onStreamFetch(event, params);\n        break;\n      }\n\n      case 'download': {\n        onDownloadFetch(event, params);\n        break;\n      }\n\n      case 'share': {\n        onShareFetch(event, params);\n        break;\n      }\n\n      case 'ping': {\n        event.respondWith(new Response('pong'));\n        break;\n      }\n\n      // default: {\n      //   event.respondWith(fetch(event.request));\n      //   break;\n      // }\n    }\n  } catch(err) {\n    log.error('fetch error', err);\n    event.respondWith(new Response('', {\n      status: 500,\n      statusText: 'Internal Server Error',\n      headers: {'Cache-Control': 'no-cache'}\n    }));\n  }\n};\n\nconst onChangeState = () => {\n  ctx.onfetch = onFetch;\n};\n\nctx.addEventListener('install', (event) => {\n  log('installing');\n  event.waitUntil(ctx.skipWaiting().then(() => log('skipped waiting'))); // Activate worker immediately\n});\n\nctx.addEventListener('activate', (event) => {\n  log('activating', ctx);\n  event.waitUntil(ctx.caches.delete(CACHE_ASSETS_NAME).then(() => log('cleared assets cache')));\n  event.waitUntil(ctx.clients.claim().then(() => log('claimed clients')));\n});\n\n// ctx.onerror = (error) => {\n//   log.error('error:', error);\n// };\n\n// ctx.onunhandledrejection = (error) => {\n//   log.error('onunhandledrejection:', error);\n// };\n\nctx.onoffline = ctx.ononline = onChangeState;\n\nonChangeState();\n"],"names":["Modes","DEBUG","ctx","MOUNT_CLASS_TO","USER_AGENT","IS_SAFARI","IS_FIREFOX","IS_SERVICE_WORKER","IS_WEB_WORKER","IS_WORKER","getWindowClients","postMessage","listener","args","err","notifyServiceWorker","all","listeners","notifyWorker","noop","_logTimer","dT","LogTypes","LOG_LEVELS","IS_WEBKIT","STYLES_SUPPORTED","LOGGER_STYLES","methods","logger","prefix","type","ignoreDebugReset","style","originalPrefix","originalStyle","log","method","logType","newPrefix","level","acc","v","_type","pause","ms","resolve","CACHE_ASSETS_NAME","isCorrectResponse","response","timeoutRace","promise","requestCache","event","cache","file","headers","url","readBlobAs","blob","reader","e","readBlobAsArrayBuffer","readBlobAsUint8Array","buffer","deferredPromise","deferredHelper","callback","deferred","reject","value","debounce","fn","shouldRunFirst","shouldRunLast","waitingTimeout","waitingPromise","hadNewCall","invoke","_resolve","_reject","result","_waitingTimeout","blobSafeMimeType","mimeType","blobConstruct","blobParts","safeMimeType","MemoryWriter","size","saveFileCallback","part","offset","endOffset","newBytes","saveToStorage","parts","CACHED_ERRORS","makeError","_CacheStorageController","dbName","entryName","fileName","rejected","timeout","res","fileSize","enabled","clearWrite","storage","CacheStorageController","delay","deferredPromises","cacheStorage","CHUNK_TTL","CHUNK_CACHED_TIME_HEADER","clearOldChunks","requests","filtered","timestamp","request","match","promises","id","mtprotoMessagePort","getMtprotoMessagePort","messagePort","taskId","streams","Stream","info","STREAM_CHUNK_UPPER_LIMIT","STREAM_CHUNK_MIDDLE_LIMIT","alignedOffset","limit","fromPreload","payload","uploadFile","serviceMessagePort","bytesPromise","key","error","bytes","end","alignOffset","range","possibleResponse","responseForSafariFirstRange","alignLimit","ab","onStreamFetch","params","parseRange","stream","SMALLEST_CHUNK_LIMIT","header","chunks","ranges","base","DATABASE_STATE","NOTIFICATION_ICON_PATH","NOTIFICATION_BADGE_PATH","deepEqual","x","y","ok","tx","safeAssign","object","fromObject","i","_IDB","db","createNew","createIndexes","os","store","indexNames","indexName","index","createObjectStore","finished","calledNew","transaction","target","instance","preserve","IDB","IDBStorage","storeName","isArray","objectStore","idx","mode","perf","onError","onComplete","results","r","waitForTransactionComplete","callbackResult","length","left","onRequestFinished","defaultBaseUrl","PING_PUSH_TIMEOUT","lastPingTime","localNotificationsAvailable","SomethingGetter","defaults","cached","getter","obj","muteUntil","settings","lang","nowTime","userInvisibleIsSupported","notificationPromise","fireNotification","notification","action","data","clientList","pendingNotification","client","onCloseNotification","notifications","removeFromNotifications","closeAllNotifications","tag","len","title","body","peerId","messageKey","ignoreMessages","actions","notificationOptions","onPing","source","onShownNotification","time","_time","tabId","indexOfAndSplice","array","item","findAndSplice","verify","EventListenerBase","reuseResults","name","options","_a","l","collectResults","arr","USE_LOCKS","SuperMessagePort","logSuffix","task","previousResolve","ret","pingResolve","innerTask","resultTaskPayload","resultTask","ackTask","isPromise","port","lock","portTasks","tasks","ports","transfer","withAck","_void","interval","ServiceMessagePort","listenMessagePort","onConnect","onDisconnect","attachPort","listenPort","sendPort","downloadMap","DOWNLOAD_ERROR","DOWNLOAD_TEST","events","strategy","controller","readable","_controller","reason","chunk","handleDownload","onDownloadFetch","cancelAllDownloads","parseFormData","formData","processShareEvent","clientId","checkWindowClientForDeferredShare","windowClient","onShareFetch","_mtprotoMessagePort","sendMessagePort","channel","sendMessagePortIfNeeded","connectedWindows","onWindowConnected","onDownloadClosedWindows","windowClients","onFetch","scope","onChangeState"],"mappings":"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"}